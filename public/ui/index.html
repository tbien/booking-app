<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rezerwacje (iCal)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <!-- App Container -->
    <main id="app"></main>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
      const { createApp, ref, computed, onMounted, watch, onBeforeUnmount } = Vue;
      createApp({
        setup() {
          const loading = ref(true);
          const error = ref('');
          const rows = ref([]); // Keep for backward compatibility, will sync with allRows
          const newName = ref('');
          const newUrl = ref('');
          const newSource = ref('');
          const appendConfig = ref(true);
          const properties = ref([]);
          const saving = ref(false);
          let saveTimer = null;

          // Centralized filter params - MUST be defined early before changeMonth()
          const filterParams = ref({
            filterMode: localStorage.getItem('filterMode') || 'sortBy',
            sortBy: 'end',
            from: '',
            to: '',
            searchText: '',
            groupId: '',
            propertyId: '',
            limit: 50,
            page: 1,
            showCancelled: false,
            daysAhead: 35,
          }); // Sync state flag
          const syncing = ref(false);

          const propertiesWithCosts = ref([]);

          // Helper function to map raw booking data to standardized format
          const mapBookingData = (rawRows) => {
            return (rawRows || []).map((it) => {
              // Backend already returns data in the correct format, just pass it through
              return {
                ...it,
                // Ensure all required fields exist with fallbacks
                Nieruchomo≈õƒá: it['Nieruchomo≈õƒá'] || it.propertyName || 'Nieznana',
                'Data rozpoczƒôcia':
                  it['Data rozpoczƒôcia'] ||
                  (it.start ? new Date(it.start).toLocaleDateString('pl-PL') : ''),
                'Data zako≈Ñczenia':
                  it['Data zako≈Ñczenia'] ||
                  (it.end ? new Date(it.end).toLocaleDateString('pl-PL') : ''),
                'Status wyjazdu':
                  it['Status wyjazdu'] ||
                  (typeof it.isUrgentChangeover === 'boolean'
                    ? it.isUrgentChangeover
                      ? 'PILNE'
                      : 'NORMALNE'
                    : 'NORMALNE'),
                Opis: it['Opis'] || it.description || '',
                ≈πr√≥d≈Ço: it['≈πr√≥d≈Ço'] || it.source || '',
                'Liczba go≈õci':
                  it['Liczba go≈õci'] !== undefined
                    ? it['Liczba go≈õci']
                    : typeof it.guests === 'number'
                    ? it.guests
                    : '',
                Notatki: it['Notatki'] || it.notes || '',
                id: it.id || it._id || '',
                groupId: it.groupId || null,
                isNew: it.isNew || false,
                isStartingToday: it.isStartingToday || false,
                createdAt: it.createdAt,
                updatedAt: it.updatedAt,
              };
            });
          };

          const selectedApartments = ref([]);

          const showApartmentDropdown = ref(false);

          const selectedGroup = ref('');

          const groups = ref([]);

          const showCancelled = ref(false);

          // Progress synchronizacji
          const syncProgress = ref({
            show: false,
            status: '', // 'fetching', 'syncing', 'done'
            percentage: 0,
            message: '',
          });

          // Flaga aby sync siƒô uruchomi≈Ç tylko raz
          let autoSyncDone = false;

          // Background sync indicator (lightweight UI when sync runs in background)
          const backgroundSyncing = ref(false);

          const modal = ref({
            show: false,
            title: '',
            message: '',
            stats: null,
          });

          const apartmentNames = computed(() => {
            // Unique apartment names from all rows
            if (!rows.value || !Array.isArray(rows.value)) return [];
            const names = rows.value.map((r) => r['Nieruchomo≈õƒá']);
            return [...new Set(names)].sort();
          });

          const filteredRows = computed(() => {
            let filtered = allRows.value;
            if (selectedGroup.value) {
              filtered = filtered.filter((row) => row.groupId === selectedGroup.value);
            }
            if (selectedApartments.value.length > 0) {
              filtered = filtered.filter((r) =>
                selectedApartments.value.includes(r['Nieruchomo≈õƒá']),
              );
            }
            return filtered;
          });

          const currentSummary = computed(() => {
            const propMap = new Map(
              propertiesWithCosts.value.map((p) => [p.name, p.cleaningCost || 0]),
            );
            let total = 0;
            filteredRows.value.forEach((row) => {
              total += propMap.get(row['Nieruchomo≈õƒá']) || 0;
            });
            const bookingCount = filteredRows.value.length;
            const uniqueProperties = new Set(filteredRows.value.map((row) => row['Nieruchomo≈õƒá']));

            let summary = `${bookingCount} rezerwacji`;
            if (uniqueProperties.size > 0) {
              summary += `, ${uniqueProperties.size} nieruchomo≈õci`;
            }
            if (total > 0) {
              summary += `, ${total} PLN`;
            }

            return summary;
          });

          const groupsWithCounts = computed(() => {
            return groups.value.map((group) => {
              const groupRows = rows.value.filter((row) => row.groupId === group._id);
              return {
                ...group,
                propertyCount: group.propertyCount || 0, // Use count from backend
                bookingCount: groupRows.length,
              };
            });
          });

          const selectedGroupData = computed(() => {
            if (!selectedGroup.value) return null;
            return groupsWithCounts.value.find((g) => g._id === selectedGroup.value);
          });

          const removeApartment = (apt) => {
            selectedApartments.value = selectedApartments.value.filter((a) => a !== apt);
          };

          const toggleApartment = (apt) => {
            const index = selectedApartments.value.indexOf(apt);
            if (index > -1) {
              selectedApartments.value.splice(index, 1);
            } else {
              selectedApartments.value.push(apt);
            }
          };

          const newBookingsCount = computed(() => {
            return filteredRows.value.filter((row) => row.isNew).length;
          });

          // Computed refs for backward compatibility with template
          const daysAhead = computed({
            get: () => filterParams.value.daysAhead,
            set: (val) => {
              filterParams.value.daysAhead = val;
            },
          });
          const sortBy = computed({
            get: () => filterParams.value.sortBy,
            set: (val) => {
              filterParams.value.sortBy = val;
            },
          });
          const from = computed({
            get: () => filterParams.value.from,
            set: (val) => {
              filterParams.value.from = val;
            },
          });
          const to = computed({
            get: () => filterParams.value.to,
            set: (val) => {
              filterParams.value.to = val;
            },
          });

          const fetchData = async () => {
            loading.value = true;
            error.value = '';
            try {
              const params = new URLSearchParams({
                sortBy: String(filterParams.value.sortBy),
              });

              // If user provided explicit from/to range, prefer that and do not send daysAhead
              if (!filterParams.value.from && !filterParams.value.to) {
                params.set('daysAhead', String(filterParams.value.daysAhead));
              }

              if (filterParams.value.from) params.set('from', filterParams.value.from);
              if (filterParams.value.to) params.set('to', filterParams.value.to);
              if (showCancelled.value) params.set('includeCancelled', 'true');

              const res = await fetch(`/ical/data?${params.toString()}`);
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'B≈ÇƒÖd');
              rows.value = mapBookingData(data.rows);
            } catch (e) {
              error.value = e.message || 'B≈ÇƒÖd';
            } finally {
              loading.value = false;
            }
          };

          const updateGuests = async (row) => {
            if (!row.id) return;
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(async () => {
              try {
                saving.value = true;
                await fetch('/ical/guests', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    id: row.id,
                    guests: Number(row['Liczba go≈õci'] || 0),
                  }),
                });
              } catch (e) {
                console.error(e);
              } finally {
                saving.value = false;
              }
            }, 500);
          };

          const updateNotes = async (row) => {
            if (!row.id) return;
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(async () => {
              try {
                saving.value = true;
                await fetch('/ical/notes', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    id: row.id,
                    notes: row['Notatki'] || '',
                  }),
                });
              } catch (e) {
                console.error(e);
              } finally {
                saving.value = false;
              }
            }, 500);
          };

          // Helper that formats a Date to local YYYY-MM-DD
          const formatLocalDate = (d) => {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
          };

          // Returns start/end Date objects for month offset from current (0 = current month, -1 = previous)
          const getMonthRange = (offsetMonths = 0) => {
            const now = new Date();
            const start = new Date(now.getFullYear(), now.getMonth() + offsetMonths, 1);
            const end = new Date(now.getFullYear(), now.getMonth() + offsetMonths + 1, 0);
            return { start, end };
          };

          // KROK 1: Nowa funkcja changeMonth - wywo≈Ça fetchBookings bezpo≈õrednio, bez debounce
          const changeMonth = async () => {
            // Direct fetch without debounce - used by setMonthByOffset
            changingMonth.value = true;
            currentPage.value = 1;
            allRows.value = [];
            rows.value = [];
            await fetchBookings(1);
            changingMonth.value = false;
          };

          // Track currently displayed month as an offset from 'now'.
          // This allows multiple clicks on Next/Previous to accumulate the offset
          // instead of always jumping to "now + 1".
          const currentMonthOffset = ref(0);

          // Apply a delta (e.g. +1 or -1) to the current month offset and reload.
          const setMonthByOffset = (delta) => {
            // update offset
            currentMonthOffset.value = (currentMonthOffset.value || 0) + delta;

            const { start, end } = getMonthRange(currentMonthOffset.value);

            // Set date range - zawsze u≈ºywaj from/to dla month navigation
            filterParams.value.from = formatLocalDate(start);
            filterParams.value.to = formatLocalDate(end);

            // First: read data from DB for immediate UX
            // (fetchBookings will call /ical/data with from/to and render rows)
            fetchBookings(1);

            // Then: start a background synchronization to update DB
            // Do not show full progress bar for background sync; use a lightweight indicator.
            // Fire-and-forget but catch errors to avoid unhandled rejections.
            try {
              // mark background sync in UI
              backgroundSyncing.value = true;
              handleSync(false)
                .catch((err) => {
                  console.error('Background sync failed:', err);
                })
                .finally(() => {
                  backgroundSyncing.value = false;
                });
            } catch (e) {
              // defensive
              backgroundSyncing.value = false;
            }
          };

          // Convenience wrappers
          const setCurrentMonth = () => {
            currentMonthOffset.value = 0;
            setMonthByOffset(0);
          };

          const setPreviousMonth = () => setMonthByOffset(-1);

          const setNextMonth = () => setMonthByOffset(1);

          // Human-friendly label for the currently displayed month (based on offset)
          const displayedMonthLabel = computed(() => {
            const now = new Date();
            const d = new Date(
              now.getFullYear(),
              now.getMonth() + (currentMonthOffset.value || 0),
              1,
            );
            // e.g. "grudzie≈Ñ 2025"
            return d.toLocaleDateString('pl-PL', { month: 'long', year: 'numeric' });
          });

          const fetchProperties = async () => {
            try {
              const res = await fetch('/ical/properties');
              const data = await res.json();
              // Group properties by name and take the cleaning cost from any source (they should be the same for logical property)
              const propMap = new Map();
              data.properties.forEach((p) => {
                if (!propMap.has(p.name)) {
                  propMap.set(p.name, { cleaningCost: p.cleaningCost || 0, sources: [] });
                }
                propMap.get(p.name).sources.push(p.source);
              });
              propertiesWithCosts.value = Array.from(propMap.entries()).map(([name, data]) => ({
                name,
                cleaningCost: data.cleaningCost,
                sources: data.sources,
              }));
            } catch (e) {
              console.error('Failed to fetch properties:', e);
            }
          };

          // Fetch live iCal reservations for an explicit range (does not write to DB)
          const fetchICalRange = async (fromDate, toDate) => {
            changingMonth.value = true;
            loading.value = true;
            error.value = '';
            try {
              const params = new URLSearchParams({
                from: fromDate,
                to: toDate,
                sortBy: String(filterParams.value.sortBy),
              });

              if (selectedGroup.value) params.set('groupId', selectedGroup.value);
              if (selectedApartments.value.length > 0)
                params.set('propertyNames', selectedApartments.value.join(','));

              const res = await fetch(`/ical/fetch?${params.toString()}`);
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'B≈ÇƒÖd');

              const mappedRows = mapBookingData(data.rows);
              allRows.value = mappedRows;
              rows.value = mappedRows;
              currentPage.value = 1;
              hasMore.value = false;
              totalCount.value = mappedRows.length;
            } catch (e) {
              error.value = e.message || 'B≈ÇƒÖd podczas pobierania iCal';
            } finally {
              loading.value = false;
              changingMonth.value = false;
            }
          };

          // Watchers dla filtr√≥w - je≈õli siƒô zmieniƒÖ, resetuj paginacjƒô
          // KROK 2: Debounce TYLKO dla rƒôcznych zmian (nie dla month change)
          let watcherDebounceTimer = null;
          watch(
            [
              () => filterParams.value.from,
              () => filterParams.value.to,
              () => filterParams.value.sortBy,
              () => filterParams.value.includeCancelled,
              () => filterParams.value.daysAhead,
              () => filterParams.value.filterMode,
              selectedGroup,
              selectedApartments,
              showCancelled,
            ],
            async () => {
              // Zapisz filterMode do localStorage
              localStorage.setItem('filterMode', filterParams.value.filterMode);

              // Pomij je≈õli month change jest w trakcie - changeMonth() ju≈º siƒô wywo≈Ça
              if (changingMonth.value) return;

              // Sync showCancelled to filterParams
              filterParams.value.includeCancelled = showCancelled.value;

              // Debounce manual changes
              if (watcherDebounceTimer) clearTimeout(watcherDebounceTimer);
              watcherDebounceTimer = setTimeout(async () => {
                currentPage.value = 1;
                allRows.value = [];
                rows.value = [];
                await fetchBookings(1);
              }, 300);
            },
          );

          // Watch for apartment selection changes - filtering done on frontend, no need to fetch
          watch(
            selectedApartments,
            () => {
              // Frontend filtering only
            },
            { deep: true },
          );

          const fetchGroups = async () => {
            try {
              const res = await fetch('/ical/groups');
              const data = await res.json();
              groups.value = data.groups;
            } catch (e) {
              console.error('Failed to fetch groups:', e);
            }
          };
          // Main data array (all fetched rows)
          const allRows = ref([]);

          // Paginacja
          const currentPage = ref(1);
          const pageSize = ref(30);
          const hasMore = ref(false);
          const totalCount = ref(0);
          const isLoadingMore = ref(false);

          // Infinite Scroll
          const sentinelElement = ref(null);
          const infiniteScrollEnabled = ref(true);
          let intersectionObserver = null;

          // Nowa ujednolicona funkcja do pobierania rezerwacji
          const fetchBookings = async (page = 1) => {
            if (page === 1) {
              loading.value = true;
            } else {
              isLoadingMore.value = true;
            }
            error.value = '';
            try {
              const params = new URLSearchParams({
                sortBy: String(filterParams.value.sortBy),
                page: String(page),
              });

              // If explicit from/to are provided (month navigation), request all rows for that range
              // and increase the limit to avoid pagination truncation.
              if (filterParams.value.from && filterParams.value.to) {
                params.set('all', 'true');
                params.set('limit', '1000');
                params.set('from', filterParams.value.from);
                params.set('to', filterParams.value.to);
                params.set('filterMode', filterParams.value.filterMode);
              } else {
                // default paginated view
                params.set('limit', String(pageSize.value));
                params.set('daysAhead', String(filterParams.value.daysAhead));
              }

              if (filterParams.value.includeCancelled) params.set('includeCancelled', 'true');
              if (selectedGroup.value) params.set('groupId', selectedGroup.value);

              const res = await fetch(`/ical/data?${params.toString()}`);
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'B≈ÇƒÖd');

              const mappedRows = mapBookingData(data.rows);

              if (page === 1) {
                allRows.value = mappedRows;
                rows.value = mappedRows; // Sync for backward compatibility
              } else {
                allRows.value.push(...mappedRows);
                rows.value.push(...mappedRows);
              }

              currentPage.value = page;
              hasMore.value = data.hasMore;
              totalCount.value = data.totalCount;
            } catch (e) {
              error.value = e.message || 'B≈ÇƒÖd';
            } finally {
              loading.value = false;
              isLoadingMore.value = false;
            }
          };

          const loadMore = () => {
            if (!isLoadingMore.value && hasMore.value) {
              fetchBookings(currentPage.value + 1);
            }
          };

          // Flag for month/range changes
          const changingMonth = ref(false);

          // Funkcja pomocnicza do updatowania progress
          const updateProgress = (percentage, status, message) => {
            syncProgress.value = {
              show: true,
              percentage,
              status,
              message,
            };
          };

          // G≈Ç√≥wna funkcja synchronizacji z progress tracking
          const handleSync = async (showProgressBar = true) => {
            if (syncing.value) return; // Unikaj duplikat√≥w

            syncing.value = true;
            try {
              if (showProgressBar) {
                updateProgress(10, 'fetching', 'Pobieranie listy nieruchomo≈õci...');
              }

              const syncData = {
                daysAhead: filterParams.value.daysAhead,
              };
              if (selectedGroup.value) {
                syncData.groupId = selectedGroup.value;
              }
              if (selectedApartments.value.length > 0) {
                syncData.propertyNames = selectedApartments.value.join(',');
              }

              if (showProgressBar) {
                updateProgress(30, 'syncing', 'Synchronizacja rezerwacji...');
              }

              const res = await fetch('/ical/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(syncData),
              });
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'Sync failed');

              if (showProgressBar) {
                updateProgress(70, 'syncing', 'Od≈õwie≈ºanie danych...');
              }

              // Refresh data after sync
              await fetchBookings(1);

              if (showProgressBar) {
                updateProgress(100, 'done', 'Synchronizacja zako≈Ñczona!');
                // Ukryj progress bar po 2 sekundach
                setTimeout(() => {
                  syncProgress.value.show = false;
                }, 2000);
              }

              // Poka≈º modal z wynikami tylko je≈õli pokazywali≈õmy progress
              if (showProgressBar) {
                setTimeout(() => {
                  showModal('Synchronizacja zako≈Ñczona!', data.message, data.stats);
                }, 2000);
              }
            } catch (e) {
              if (showProgressBar) {
                updateProgress(0, 'error', 'B≈ÇƒÖd synchronizacji');
                setTimeout(() => {
                  syncProgress.value.show = false;
                }, 2000);
              }
              showModal('B≈ÇƒÖd synchronizacji', e.message, null);
            } finally {
              syncing.value = false;
            }
          };

          const syncNow = async () => {
            await handleSync(true); // true = poka≈º progress bar dla manual sync
          };

          const showModal = (title, message, stats = null) => {
            // Translate stats keys to Polish
            const translatedStats = stats
              ? {
                  'Zsynchronizowane nieruchomo≈õci': stats.propertiesSynced,
                  'Zaktualizowane rezerwacje': stats.bookingsUpdated,
                  'Anulowane rezerwacje': stats.bookingsCancelled,
                }
              : null;

            modal.value = {
              show: true,
              title,
              message,
              stats: translatedStats,
            };
          };

          const closeModal = () => {
            modal.value.show = false;
          };

          // Load initial data when component mounts
          onMounted(async () => {
            try {
              // Krok 1: Paralelne ≈Çadowanie danych
              await Promise.all([fetchBookings(1), fetchProperties(), fetchGroups()]);

              // Krok 2: Automatyczna synchronizacja przy pierwszym wej≈õciu
              if (!autoSyncDone) {
                autoSyncDone = true;
                await handleSync(false); // false = nie pokazuj progress baru dla auto-sync
              }

              // Krok 3: Setup Intersection Observer dla infinite scroll
              if (sentinelElement.value && 'IntersectionObserver' in window) {
                const observerOptions = {
                  root: null,
                  rootMargin: '100px',
                  threshold: 0.1,
                };

                intersectionObserver = new IntersectionObserver((entries) => {
                  entries.forEach((entry) => {
                    // Trigger loadMore je≈õli sentinel jest widoczny, jest wiƒôcej danych i nie ≈Çadujemy
                    if (entry.isIntersecting && hasMore.value && !isLoadingMore.value) {
                      loadMore();
                    }
                  });
                }, observerOptions);

                intersectionObserver.observe(sentinelElement.value);
              } else {
                // Fallback dla starszych przeglƒÖdarek - wy≈ÇƒÖcz infinite scroll
                infiniteScrollEnabled.value = false;
              }
            } catch (err) {
              console.error('B≈ÇƒÖd podczas inicjalizacji aplikacji:', err);
            }
          });

          // Cleanup observer na unmount
          onBeforeUnmount(() => {
            if (intersectionObserver) {
              intersectionObserver.disconnect();
            }
            // Clear any pending save timers to prevent memory leaks
            if (saveTimer) {
              clearTimeout(saveTimer);
            }
          });

          return {
            loading,
            error,
            rows,
            allRows,
            filterParams,
            daysAhead,
            sortBy,
            displayedMonthLabel,
            fetchBookings,
            fetchData,
            loadMore,
            currentPage,
            pageSize,
            hasMore,
            totalCount,
            isLoadingMore,
            sentinelElement,
            infiniteScrollEnabled,
            newName,
            newUrl,
            newSource,
            properties,
            appendConfig,
            updateGuests,
            updateNotes,
            saving,
            from,
            to,
            setCurrentMonth,
            setPreviousMonth,
            setNextMonth,
            selectedApartments,
            apartmentNames,
            filteredRows,
            showApartmentDropdown,
            currentSummary,
            selectedGroup,
            groups,
            groupsWithCounts,
            selectedGroupData,
            newBookingsCount,
            syncing,
            backgroundSyncing,
            syncNow,
            syncProgress,
            showCancelled,
            modal,
            showModal,
            closeModal,
            removeApartment,
            toggleApartment,
            changingMonth,
          };
        },
        template: `
          <div class="container">
            <!-- Progress Bar for Sync -->
            <div v-if="syncProgress.show" class="sync-progress-bar">
              <div class="progress-container">
                <p class="progress-message">{{ syncProgress.message }}</p>
                <div class="progress-bar">
                  <div class="progress-fill" :style="{ width: syncProgress.percentage + '%' }"></div>
                </div>
                <span class="progress-percentage">{{ syncProgress.percentage }}%</span>
              </div>
            </div>

            <a href="/config" class="config-button">Konfiguracja iCal</a>
            <h1>Rezerwacje (nastƒôpne 35 dni)</h1>
            
            <!-- Group Selection Toolbar -->
            <div class="toolbar mb-4">
              <button 
                @click="selectedGroup = ''" 
                :class="['px-4 py-2 rounded', selectedGroup === '' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600']"
              >
                Wszystkie
              </button>
              <button 
                v-for="group in groupsWithCounts" 
                :key="group._id" 
                @click="selectedGroup = group._id" 
                :class="['px-4 py-2 rounded ml-2', selectedGroup === group._id ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600']"
              >
                {{ group.name }} 
                <span class="text-sm opacity-75">({{ group.propertyCount }} obj., {{ group.bookingCount }} rez.)</span>
              </button>
            </div>

            <p style="display:flex; align-items:center; gap:10px;">Podsumowanie: {{ currentSummary }}
              <span v-if="newBookingsCount > 0" class="new-badge">{{ newBookingsCount }} nowych</span>
              <small v-if="backgroundSyncing" style="color:#ffd700; margin-left:8px; font-style:italic;">synchronizacja w tle...</small>
            </p>

            <!-- Main Controls Toolbar -->
            <div class="main-toolbar">
              <!-- Left Section: Filters -->
              <div class="toolbar-section">
                <div class="filter-group">
                  <label class="filter-label">Zakres dni:</label>
                  <input type="number" min="1" max="365" v-model.number="daysAhead" class="filter-input"/>
                </div>

                <div class="filter-group">
                  <label class="filter-label">Sortuj po:</label>
                  <select v-model="sortBy" class="filter-select">
                    <option value="start">przyje≈∫dzie</option>
                    <option value="end">wyje≈∫dzie</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label class="filter-label">Od:</label>
                  <input type="date" v-model="from" class="filter-input"/>
                </div>

                <div class="filter-group">
                  <label class="filter-label">Do:</label>
                  <input type="date" v-model="to" class="filter-input"/>
                </div>
              </div>

              <!-- Center Section: Quick Actions -->
              <div class="toolbar-section">
                <div class="button-group">
                  <button @click="setPreviousMonth" :disabled="changingMonth" class="action-button">{{ changingMonth ? '‚è≥' : '‚óÄ Poprzedni' }}</button>
                  <button @click="setCurrentMonth" :disabled="changingMonth" class="action-button primary">{{ changingMonth ? '≈Åadujƒô...' : 'Aktualny' }}</button>
                    <button @click="setNextMonth" :disabled="changingMonth" class="action-button">{{ changingMonth ? '‚è≥' : 'Nastƒôpny ‚ñ∂' }}</button>
                  </div>

                  <div class="month-label" style="margin-top:6px; text-align:center; color:#ddd; font-size:0.95rem;">
                    {{ displayedMonthLabel }}
                  </div>
                </div>
              </div>

              <!-- Right Section: Main Actions -->
              <div class="toolbar-section">
                <div class="button-group">
                  <button @click="showCancelled = !showCancelled" :class="['action-button', showCancelled ? 'active' : '']">
                    {{ showCancelled ? 'Ukryj anulowane' : 'Poka≈º anulowane' }}
                  </button>
                  <button 
                    @click="filterParams.filterMode = filterParams.filterMode === 'sortBy' ? 'overlap' : 'sortBy'" 
                    :class="['action-button', filterParams.filterMode === 'overlap' ? 'active' : '']"
                    title="Tryb filtrowania: 'Wed≈Çug daty' pokazuje tylko rezerwacje z check-in/out w miesiƒÖcu. 'Wszystkie' pokazuje rezerwacje przecinajƒÖce miesiƒÖc."
                  >
                    {{ filterParams.filterMode === 'overlap' ? 'üìÖ Wszystkie' : 'üìÖ Wed≈Çug daty' }}
                  </button>
                  <button @click="syncNow" :disabled="syncing" class="action-button sync">
                    {{ syncing ? 'Synchronizujƒô...' : 'Synchronizuj iCal' }}
                  </button>
                </div>
              </div>
            </div>
<div class="apartment-dropdown-container">
  <div
    class="apartment-select-trigger"
    @click="showApartmentDropdown = !showApartmentDropdown"
    tabindex="0"
    @blur="showApartmentDropdown = false"
  >
    <span v-if="!selectedApartments || !selectedApartments.length" class="placeholder">Filtruj nieruchomo≈õci</span>
    <span v-else-if="selectedApartments && selectedApartments.length">
      <span v-for="apt in selectedApartments" :key="apt" class="chip">{{ apt }} <button @click.stop="removeApartment(apt)">√ó</button></span>
    </span>
    <span class="arrow">‚ñº</span>
  </div>
  <div
    v-if="showApartmentDropdown"
    class="apartment-dropdown"
    @mousedown.prevent
  >
    <label v-for="name in apartmentNames" :key="name" @click="toggleApartment(name)">
      <input
        type="checkbox"
        :value="name"
        v-model="selectedApartments"
        @click.stop
      />
      {{ name }}
    </label>
  </div>
</div>
            <div class="card">
              <div v-if="loading">≈Åadowanie...</div>
              <div v-else-if="error">B≈ÇƒÖd: {{ error }}</div>
              <div v-else>
                <div style="overflow-x:auto;">
                  <table>
                    <thead>
                      <tr>
                        <th>Nieruchomo≈õƒá</th>
                        <th>Check-in</th>
                        <th>Check-out</th>
                        <th>Status wyjazdu</th>
                        <th>Liczba go≈õci</th>
                        <th>Notatki</th>
                        <th class="muted">Opis</th>
                        <th class="muted">≈πr√≥d≈Ço</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr v-for="r in filteredRows" :key="r.id || r._id" :class="{ 'new-booking': r.isNew, 'cancelled-booking': r.cancellationStatus === 'cancelled' || r.cancellationStatus === true }">
                        <td>
                          {{ r['Nieruchomo≈õƒá'] }}
                          <span v-if="r.isNew" class="new-badge">NOWE</span>
                          <span v-if="r.isStartingToday" class="arrival-today-badge">PRZYJAZD</span>
                          <span v-if="r.cancellationStatus === 'cancelled' || r.cancellationStatus === true" class="cancelled-badge">üö´ ANULOWANA</span>
                        </td>
                        <td>{{ r['Data rozpoczƒôcia'] }}</td>
                        <td>{{ r['Data zako≈Ñczenia'] }}</td>
                        <td>
                          <span :class="['badge', r['Status wyjazdu'] === 'PILNE' ? 'badge-pilne' : 'badge-normalne']">
                            {{ r['Status wyjazdu'] }}
                          </span>
                        </td>
                        <td>
                          <input class="input input-small" type="number" min="0" max="20" v-model.number="r['Liczba go≈õci']" @input="updateGuests(r)" />
                        </td>
                        <td>
                          <input class="input input-medium" type="text" v-model="r['Notatki']" @input="updateNotes(r)" />
                        </td>
                        <td class="muted opis-cell">{{ r['Opis'] }}</td>
                        <td class="muted"><a :href="r['≈πr√≥d≈Ço']" target="_blank">≈∫r√≥d≈Ço</a></td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="footer">Wskaz√≥wka: Status wyjazdu = "PILNE" oznacza przyjazd tego samego dnia. <span v-if="saving" class="saving-indicator">Zapisujƒô...</span></div>
                
                <!-- Infinite Scroll Sentinel Element -->
                <div ref="sentinelElement" class="sentinel-element"></div>
                
                <!-- Manual Load More Button (fallback for touch devices) -->
                <div v-if="hasMore && !infiniteScrollEnabled" style="text-align:center; margin-top:12px;">
                  <button class="load-more-btn" @click="loadMore" :disabled="isLoadingMore">
                    {{ isLoadingMore ? '≈Åadujƒô...' : 'Za≈Çaduj wiƒôcej' }} ({{ allRows.length }} / {{ totalCount }})
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Modal -->
          <div class="modal-overlay" :class="{ active: modal.show }" @click="closeModal">
            <div class="modal-content" @click.stop>
              <div class="modal-header">
                <h3 class="modal-title">{{ modal.title }}</h3>
                <button class="modal-close" @click="closeModal">&times;</button>
              </div>
              <div class="modal-body">
                <p>{{ modal.message }}</p>
                <div v-if="modal.stats" class="modal-stats">
                  <div v-for="(value, key) in modal.stats" :key="key" class="modal-stat">
                    <span class="modal-stat-label">{{ key }}:</span>
                    <span class="modal-stat-value">{{ value }}</span>
                  </div>
                </div>
              </div>
              <div class="modal-actions">
                <button class="modal-btn modal-btn-primary" @click="closeModal">OK</button>
              </div>
            </div>
          </div>
        `,
      }).mount('#app');
    </script>
  </body>
</html>
