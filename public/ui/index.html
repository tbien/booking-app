<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rezerwacje (iCal)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <!-- App Container -->
    <div id="app" v-cloak></div>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
      const { createApp, ref, computed, onMounted, watch, onBeforeUnmount } = Vue;
      createApp({
        setup() {
          const loading = ref(true);
          const error = ref('');
          const rows = ref([]); // Keep for backward compatibility, will sync with allRows
          const newName = ref('');
          const newUrl = ref('');
          const newSource = ref('');
          const appendConfig = ref(true);
          const properties = ref([]);
          const saving = ref(false);
          let saveTimer = null;

          // Rola uÅ¼ytkownika (null = jeszcze nieznana, 'user' = niezalogowany, 'admin' = zalogowany)
          const userRole = ref(null);
          const isAdmin = computed(() => userRole.value === 'admin');

          const fetchRole = async () => {
            try {
              const res = await fetch('/auth/me');
              const data = await res.json();
              userRole.value = data.role || 'user';
            } catch {
              userRole.value = 'user';
            }
          };

          const logout = async () => {
            await fetch('/auth/logout', { method: 'POST' });
            userRole.value = 'user';
            window.location.reload();
          };

          // Helper to format date as YYYY-MM-DD
          const formatDate = (date) => {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
          };

          // Calculate default dates: current month (1st to last day) + next month
          const now = new Date();
          const defaultStart = new Date(now.getFullYear(), now.getMonth(), 1); // 1st of current month
          const defaultEnd = new Date(now.getFullYear(), now.getMonth() + 2, 0); // Last day of next month

          // Centralized filter params - MUST be defined early before changeMonth()
          const filterParams = ref({
            filterMode: localStorage.getItem('filterMode') || 'sortBy',
            sortBy: 'end',
            from: formatDate(defaultStart),
            to: formatDate(defaultEnd),
            searchText: '',
            groupId: '',
            propertyId: '',
            limit: 50,
            page: 1,
            showCancelled: false,
          }); // Sync state flag
          const syncing = ref(false);

          const propertiesWithCosts = ref([]);

          // Helper function to map raw booking data to standardized format
          const mapBookingData = (rawRows) => {
            return (rawRows || []).map((it) => {
              // Backend already returns data in the correct format, just pass it through
              return {
                ...it,
                // Ensure all required fields exist with fallbacks
                NieruchomoÅ›Ä‡: it['NieruchomoÅ›Ä‡'] || it.propertyName || 'Nieznana',
                'Data rozpoczÄ™cia':
                  it['Data rozpoczÄ™cia'] ||
                  (it.start ? new Date(it.start).toLocaleDateString('pl-PL') : ''),
                'Data zakoÅ„czenia':
                  it['Data zakoÅ„czenia'] ||
                  (it.end ? new Date(it.end).toLocaleDateString('pl-PL') : ''),
                'Status wyjazdu':
                  it['Status wyjazdu'] ||
                  (typeof it.isUrgentChangeover === 'boolean'
                    ? it.isUrgentChangeover
                      ? 'PILNE'
                      : 'NORMALNE'
                    : 'NORMALNE'),
                Opis: it['Opis'] || it.description || '',
                Å¹rÃ³dÅ‚o: it['Å¹rÃ³dÅ‚o'] || it.source || '',
                'Liczba goÅ›ci':
                  it['Liczba goÅ›ci'] !== undefined
                    ? it['Liczba goÅ›ci']
                    : typeof it.guests === 'number'
                      ? it.guests
                      : '',
                Notatki: it['Notatki'] || it.notes || '',
                id: it.id || it._id || '',
                groupId: it.groupId || null,
                isNew: it.isNew || false,
                isStartingToday: it.isStartingToday || false,
                createdAt: it.createdAt,
                updatedAt: it.updatedAt,
                _start: it._start,
                _end: it._end,
              };
            });
          };

          const selectedApartments = ref([]);

          const showApartmentDropdown = ref(false);

          const selectedGroup = ref('');

          const groups = ref([]);

          const showCancelled = ref(false);

          // Progress synchronizacji
          const syncProgress = ref({
            show: false,
            status: '', // 'fetching', 'syncing', 'done'
            percentage: 0,
            message: '',
          });

          // Flaga aby sync siÄ™ uruchomiÅ‚ tylko raz
          let autoSyncDone = false;

          // Background sync indicator (lightweight UI when sync runs in background)
          const backgroundSyncing = ref(false);

          const modal = ref({
            show: false,
            title: '',
            message: '',
            stats: null,
          });

          const apartmentNames = computed(() => {
            // Unique apartment names from all rows
            if (!rows.value || !Array.isArray(rows.value)) return [];
            const names = rows.value.map((r) => r['NieruchomoÅ›Ä‡']);
            return [...new Set(names)].sort();
          });

          const filteredRows = computed(() => {
            let filtered = allRows.value;
            if (selectedGroup.value) {
              filtered = filtered.filter((row) => row.groupId === selectedGroup.value);
            }
            if (selectedApartments.value.length > 0) {
              filtered = filtered.filter((r) =>
                selectedApartments.value.includes(r['NieruchomoÅ›Ä‡']),
              );
            }
            // Sortowanie frontendowe po dacie przyjazdu lub wyjazdu
            const key = filterParams.value.sortBy === 'start' ? '_start' : '_end';
            filtered = [...filtered].sort((a, b) => {
              const da = a[key] ? new Date(a[key]).getTime() : 0;
              const db = b[key] ? new Date(b[key]).getTime() : 0;
              return da - db;
            });
            return filtered;
          });

          const currentSummary = computed(() => {
            const propMap = new Map(
              propertiesWithCosts.value.map((p) => [p.name, p.cleaningCost || 0]),
            );
            let total = 0;
            filteredRows.value.forEach((row) => {
              total += propMap.get(row['NieruchomoÅ›Ä‡']) || 0;
            });
            const bookingCount = filteredRows.value.length;
            const uniqueProperties = new Set(filteredRows.value.map((row) => row['NieruchomoÅ›Ä‡']));

            let summary = `${bookingCount} rezerwacji`;
            if (uniqueProperties.size > 0) {
              summary += `, ${uniqueProperties.size} nieruchomoÅ›ci`;
            }
            if (isAdmin.value && total > 0) {
              summary += `, ${total} PLN`;
            }

            return summary;
          });

          const groupsWithCounts = computed(() => {
            return groups.value.map((group) => {
              const groupRows = rows.value.filter((row) => row.groupId === group._id);
              return {
                ...group,
                propertyCount: group.propertyCount || 0, // Use count from backend
                bookingCount: groupRows.length,
              };
            });
          });

          const selectedGroupData = computed(() => {
            if (!selectedGroup.value) return null;
            return groupsWithCounts.value.find((g) => g._id === selectedGroup.value);
          });

          const removeApartment = (apt) => {
            selectedApartments.value = selectedApartments.value.filter((a) => a !== apt);
          };

          const toggleApartment = (apt) => {
            const index = selectedApartments.value.indexOf(apt);
            if (index > -1) {
              selectedApartments.value.splice(index, 1);
            } else {
              selectedApartments.value.push(apt);
            }
          };

          const newBookingsCount = computed(() => {
            return filteredRows.value.filter((row) => row.isNew).length;
          });

          // Computed refs for backward compatibility with template
          const sortBy = computed({
            get: () => filterParams.value.sortBy,
            set: (val) => {
              filterParams.value.sortBy = val;
            },
          });
          const from = computed({
            get: () => filterParams.value.from,
            set: (val) => {
              filterParams.value.from = val;
            },
          });
          const to = computed({
            get: () => filterParams.value.to,
            set: (val) => {
              filterParams.value.to = val;
            },
          });

          const fetchData = async () => {
            loading.value = true;
            error.value = '';
            try {
              const params = new URLSearchParams({
                sortBy: String(filterParams.value.sortBy),
              });

              // Always send from/to dates
              if (filterParams.value.from) params.set('from', filterParams.value.from);
              if (filterParams.value.to) params.set('to', filterParams.value.to);
              if (showCancelled.value) params.set('includeCancelled', 'true');

              const res = await fetch(`/ical/data?${params.toString()}`);
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'BÅ‚Ä…d');
              rows.value = mapBookingData(data.rows);
            } catch (e) {
              error.value = e.message || 'BÅ‚Ä…d';
            } finally {
              loading.value = false;
            }
          };

          const updateGuests = async (row) => {
            if (!row.id) return;
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(async () => {
              try {
                saving.value = true;
                await fetch('/ical/guests', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    id: row.id,
                    guests: Number(row['Liczba goÅ›ci'] || 0),
                  }),
                });
              } catch (e) {
                console.error(e);
              } finally {
                saving.value = false;
              }
            }, 500);
          };

          const updateNotes = async (row) => {
            if (!row.id) return;
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(async () => {
              try {
                saving.value = true;
                await fetch('/ical/notes', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    id: row.id,
                    notes: row['Notatki'] || '',
                  }),
                });
              } catch (e) {
                console.error(e);
              } finally {
                saving.value = false;
              }
            }, 500);
          };

          // Helper that formats a Date to local YYYY-MM-DD
          const formatLocalDate = (d) => {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
          };

          // Flag for month/range changes - must be declared before functions that use it
          const changingMonth = ref(false);

          // Returns start/end Date objects for month offset from current (0 = current month, -1 = previous)
          const getMonthRange = (offsetMonths = 0) => {
            const now = new Date();
            const start = new Date(now.getFullYear(), now.getMonth() + offsetMonths, 1);
            const end = new Date(now.getFullYear(), now.getMonth() + offsetMonths + 1, 0);
            return { start, end };
          };

          // KROK 1: Nowa funkcja changeMonth - wywoÅ‚a fetchBookings bezpoÅ›rednio, bez debounce
          const changeMonth = async () => {
            // Direct fetch without debounce - used by setMonthByOffset
            changingMonth.value = true;
            currentPage.value = 1;
            allRows.value = [];
            rows.value = [];
            await fetchBookings(1);
            changingMonth.value = false;
          };

          // Track currently displayed month as an offset from 'now'.
          // This allows multiple clicks on Next/Previous to accumulate the offset
          // instead of always jumping to "now + 1".
          const currentMonthOffset = ref(0);

          // Apply a delta (e.g. +1 or -1) to the current month offset and reload.
          const setMonthByOffset = async (delta) => {
            // Prevent watcher from triggering during month change
            changingMonth.value = true;

            try {
              // update offset
              currentMonthOffset.value = (currentMonthOffset.value || 0) + delta;

              const { start, end } = getMonthRange(currentMonthOffset.value);

              console.log('ğŸ”„ setMonthByOffset', {
                delta,
                newOffset: currentMonthOffset.value,
                dateRange: `${formatLocalDate(start)} â†’ ${formatLocalDate(end)}`,
              });

              // Set date range - zawsze uÅ¼ywaj from/to dla month navigation
              filterParams.value.from = formatLocalDate(start);
              filterParams.value.to = formatLocalDate(end);
              // filterMode remains as user selected in UI

              // First: read data from DB for immediate UX
              // (fetchBookings will call /ical/data with from/to and render rows)
              await fetchBookings(1);

              // Then: start a background synchronization to update DB FOR THIS SPECIFIC MONTH
              // After sync completes, refresh data to show newly synced bookings
              if (isAdmin.value) {
                try {
                  // mark background sync in UI
                  backgroundSyncing.value = true;
                  // Pass the specific month dates to sync
                  await handleSync(false, formatLocalDate(start), formatLocalDate(end));
                  // Refresh data after background sync completes
                  await fetchBookings(1);
                } catch (err) {
                  console.error('Background sync failed:', err);
                } finally {
                  backgroundSyncing.value = false;
                }
              }
            } finally {
              // Re-enable watcher after month change completes
              changingMonth.value = false;
            }
          };

          // Convenience wrappers
          const setCurrentMonth = async () => {
            // Prevent watcher from triggering during month change
            changingMonth.value = true;

            try {
              // Reset offset to 0 and reload current month
              currentMonthOffset.value = 0;
              const { start, end } = getMonthRange(0);
              filterParams.value.from = formatLocalDate(start);
              filterParams.value.to = formatLocalDate(end);
              // filterMode remains as user selected in UI
              await fetchBookings(1);

              // Background sync for current month (tylko admin)
              if (isAdmin.value) {
                try {
                  backgroundSyncing.value = true;
                  await handleSync(false, formatLocalDate(start), formatLocalDate(end));
                  // Refresh after sync
                  await fetchBookings(1);
                } catch (e) {
                  console.error('Background sync failed:', e);
                } finally {
                  backgroundSyncing.value = false;
                }
              }
            } finally {
              // Re-enable watcher after month change completes
              changingMonth.value = false;
            }
          };

          const setPreviousMonth = () => setMonthByOffset(-1);

          const setNextMonth = () => setMonthByOffset(1);

          // Human-friendly label for the currently displayed month (based on offset)
          const displayedMonthLabel = computed(() => {
            const now = new Date();
            const d = new Date(
              now.getFullYear(),
              now.getMonth() + (currentMonthOffset.value || 0),
              1,
            );
            // e.g. "grudzieÅ„ 2025"
            return d.toLocaleDateString('pl-PL', { month: 'long', year: 'numeric' });
          });

          const fetchProperties = async () => {
            try {
              const res = await fetch('/ical/properties');
              if (!res.ok) return; // 401 gdy niezalogowany â€“ cicho ignoruj
              const data = await res.json();
              // Group properties by name and take the cleaning cost from any source (they should be the same for logical property)
              const propMap = new Map();
              (data.properties || []).forEach((p) => {
                const key = p.name;
                if (!propMap.has(key)) {
                  propMap.set(key, {
                    displayName: p.displayName || p.name,
                    cleaningCost: p.cleaningCost || 0,
                    sources: [],
                  });
                }
                propMap.get(key).sources.push(p.source);
              });
              propertiesWithCosts.value = Array.from(propMap.entries()).map(([name, info]) => ({
                name: info.displayName, // use displayName so cost lookup matches row['NieruchomoÅ›Ä‡']
                internalName: name,
                // Only expose cleaningCost to admins
                cleaningCost: isAdmin.value ? info.cleaningCost : 0,
                sources: info.sources,
              }));
            } catch (e) {
              console.error('Failed to fetch properties:', e);
            }
          };

          // Fetch live iCal reservations for an explicit range (does not write to DB)
          const fetchICalRange = async (fromDate, toDate) => {
            changingMonth.value = true;
            loading.value = true;
            error.value = '';
            try {
              const params = new URLSearchParams({
                from: fromDate,
                to: toDate,
                sortBy: String(filterParams.value.sortBy),
              });

              if (selectedGroup.value) params.set('groupId', selectedGroup.value);
              if (selectedApartments.value.length > 0)
                params.set('propertyNames', selectedApartments.value.join(','));

              const res = await fetch(`/ical/fetch?${params.toString()}`);
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'BÅ‚Ä…d');

              const mappedRows = mapBookingData(data.rows);
              allRows.value = mappedRows;
              rows.value = mappedRows;
              currentPage.value = 1;
              hasMore.value = false;
              totalCount.value = mappedRows.length;
            } catch (e) {
              error.value = e.message || 'BÅ‚Ä…d podczas pobierania iCal';
            } finally {
              loading.value = false;
              changingMonth.value = false;
            }
          };

          // Watchers dla filtrÃ³w - jeÅ›li siÄ™ zmieniÄ…, resetuj paginacjÄ™
          // KROK 2: Debounce TYLKO dla rÄ™cznych zmian (nie dla month change)
          let watcherDebounceTimer = null;
          watch(
            [
              () => filterParams.value.from,
              () => filterParams.value.to,
              () => filterParams.value.includeCancelled,
              () => filterParams.value.filterMode,
              selectedGroup,
              selectedApartments,
              showCancelled,
            ],
            async () => {
              // Zapisz filterMode do localStorage
              localStorage.setItem('filterMode', filterParams.value.filterMode);

              // Pomij jeÅ›li month change jest w trakcie - changeMonth() juÅ¼ siÄ™ wywoÅ‚a
              if (changingMonth.value) return;

              // Sync showCancelled to filterParams
              filterParams.value.includeCancelled = showCancelled.value;

              // Debounce manual changes
              if (watcherDebounceTimer) clearTimeout(watcherDebounceTimer);
              watcherDebounceTimer = setTimeout(async () => {
                currentPage.value = 1;
                allRows.value = [];
                rows.value = [];
                await fetchBookings(1);
              }, 300);
            },
          );

          // Watch for apartment selection changes - filtering done on frontend, no need to fetch
          watch(
            selectedApartments,
            () => {
              // Frontend filtering only
            },
            { deep: true },
          );

          const fetchGroups = async () => {
            try {
              const res = await fetch('/ical/groups');
              const data = await res.json();
              groups.value = data.groups;
            } catch (e) {
              console.error('Failed to fetch groups:', e);
            }
          };
          // Main data array (all fetched rows)
          const allRows = ref([]);

          // Paginacja
          const currentPage = ref(1);
          const pageSize = ref(30);
          const hasMore = ref(false);
          const totalCount = ref(0);
          const isLoadingMore = ref(false);

          // Infinite Scroll
          const sentinelElement = ref(null);
          const infiniteScrollEnabled = ref(true);
          let intersectionObserver = null;

          // Nowa ujednolicona funkcja do pobierania rezerwacji
          const fetchBookings = async (page = 1) => {
            if (page === 1) {
              loading.value = true;
            } else {
              isLoadingMore.value = true;
            }
            error.value = '';
            try {
              const params = new URLSearchParams({
                page: String(page),
              });

              // Always use from/to dates
              params.set('all', 'true');
              params.set('limit', '1000');
              params.set('from', filterParams.value.from);
              params.set('to', filterParams.value.to);
              params.set('filterMode', filterParams.value.filterMode);

              if (filterParams.value.includeCancelled) params.set('includeCancelled', 'true');
              if (selectedGroup.value) params.set('groupId', selectedGroup.value);

              console.log('ğŸ“… Fetching bookings:', {
                from: filterParams.value.from,
                to: filterParams.value.to,
                sortBy: filterParams.value.sortBy,
                filterMode: filterParams.value.filterMode,
                url: `/ical/data?${params.toString()}`,
              });

              const res = await fetch(`/ical/data?${params.toString()}`);
              const data = await res.json();

              console.log('ğŸ“Š Received bookings:', {
                count: data.count,
                totalCount: data.totalCount,
                hasMore: data.hasMore,
                from: filterParams.value.from,
                to: filterParams.value.to,
                page,
              });

              if (!data.success) throw new Error(data.error || 'BÅ‚Ä…d');

              const mappedRows = mapBookingData(data.rows);

              if (page === 1) {
                allRows.value = mappedRows;
                rows.value = mappedRows; // Sync for backward compatibility
              } else {
                allRows.value.push(...mappedRows);
                rows.value.push(...mappedRows);
              }

              currentPage.value = page;
              hasMore.value = data.hasMore;
              totalCount.value = data.totalCount;
            } catch (e) {
              error.value = e.message || 'BÅ‚Ä…d';
            } finally {
              loading.value = false;
              isLoadingMore.value = false;
            }
          };

          const loadMore = () => {
            if (!isLoadingMore.value && hasMore.value) {
              fetchBookings(currentPage.value + 1);
            }
          };

          // Funkcja pomocnicza do updatowania progress
          const updateProgress = (percentage, status, message) => {
            syncProgress.value = {
              show: true,
              percentage,
              status,
              message,
            };
          };

          // GÅ‚Ã³wna funkcja synchronizacji z progress tracking
          const handleSync = async (showProgressBar = true, fromDate = null, toDate = null) => {
            if (!isAdmin.value) return; // Tylko admin moÅ¼e synchronizowaÄ‡
            if (syncing.value) return; // Unikaj duplikatÃ³w

            syncing.value = true;
            try {
              if (showProgressBar) {
                updateProgress(10, 'fetching', 'Pobieranie listy nieruchomoÅ›ci...');
              }

              const syncData = {
                from: fromDate || filterParams.value.from,
                to: toDate || filterParams.value.to,
              };
              if (selectedGroup.value) {
                syncData.groupId = selectedGroup.value;
              }
              if (selectedApartments.value.length > 0) {
                syncData.propertyNames = selectedApartments.value.join(',');
              }

              if (showProgressBar) {
                updateProgress(30, 'syncing', 'Synchronizacja rezerwacji...');
              }

              const res = await fetch('/ical/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(syncData),
              });
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'Sync failed');

              // JeÅ›li sync wykryÅ‚ konflikty z rÄ™cznymi rezerwacjami â€“ pokaÅ¼ modal
              if (data.conflicts && data.conflicts.length > 0) {
                openConflictModal(data.conflicts);
              }

              if (showProgressBar) {
                updateProgress(70, 'syncing', 'OdÅ›wieÅ¼anie danych...');

                // Refresh data after sync ONLY if showing progress bar (manual sync)
                await fetchBookings(1);

                updateProgress(100, 'done', 'Synchronizacja zakoÅ„czona!');
                // Ukryj progress bar po 2 sekundach
                setTimeout(() => {
                  syncProgress.value.show = false;
                }, 2000);
              }

              // PokaÅ¼ modal z wynikami tylko jeÅ›li pokazywaliÅ›my progress
              if (showProgressBar) {
                setTimeout(() => {
                  showModal('Synchronizacja zakoÅ„czona!', data.message, data.stats);
                }, 2000);
              }
            } catch (e) {
              if (showProgressBar) {
                updateProgress(0, 'error', 'BÅ‚Ä…d synchronizacji');
                setTimeout(() => {
                  syncProgress.value.show = false;
                }, 2000);
              }
              showModal('BÅ‚Ä…d synchronizacji', e.message, null);
            } finally {
              syncing.value = false;
            }
          };

          const syncNow = async () => {
            await handleSync(true); // true = pokaÅ¼ progress bar dla manual sync
          };

          const showModal = (title, message, stats = null) => {
            // Translate stats keys to Polish
            const translatedStats = stats
              ? {
                  'Zsynchronizowane nieruchomoÅ›ci': stats.propertiesSynced,
                  'Zaktualizowane rezerwacje': stats.bookingsUpdated,
                  'Anulowane rezerwacje': stats.bookingsCancelled,
                }
              : null;

            modal.value = {
              show: true,
              title,
              message,
              stats: translatedStats,
            };
          };

          const closeModal = () => {
            modal.value.show = false;
          };

          // Load initial data when component mounts
          onMounted(async () => {
            try {
              // Krok 0: Pobierz rolÄ™ uÅ¼ytkownika
              await fetchRole();

              // Krok 1: Pobierz ustawienia aplikacji (domyÅ›lna grupa)
              try {
                const settingsRes = await fetch('/ical/settings');
                const settingsData = await settingsRes.json();
                if (settingsData.success && settingsData.settings?.defaultGroupId) {
                  const gid =
                    settingsData.settings.defaultGroupId._id ||
                    settingsData.settings.defaultGroupId;
                  selectedGroup.value = String(gid);
                }
              } catch {
                // ignoruj â€“ brak ustawieÅ„ nie blokuje aplikacji
              }

              // Krok 2: Paralelne Å‚adowanie danych
              await Promise.all([fetchBookings(1), fetchProperties(), fetchGroups()]);

              // Krok 2: Automatyczna synchronizacja przy pierwszym wejÅ›ciu (tylko admin)
              if (!autoSyncDone && isAdmin.value) {
                autoSyncDone = true;
                await handleSync(false); // false = nie pokazuj progress baru dla auto-sync
              }

              // Krok 3: Setup Intersection Observer dla infinite scroll
              if (sentinelElement.value && 'IntersectionObserver' in window) {
                const observerOptions = {
                  root: null,
                  rootMargin: '100px',
                  threshold: 0.1,
                };

                intersectionObserver = new IntersectionObserver((entries) => {
                  entries.forEach((entry) => {
                    // Trigger loadMore jeÅ›li sentinel jest widoczny, jest wiÄ™cej danych i nie Å‚adujemy
                    if (entry.isIntersecting && hasMore.value && !isLoadingMore.value) {
                      loadMore();
                    }
                  });
                }, observerOptions);

                intersectionObserver.observe(sentinelElement.value);
              } else {
                // Fallback dla starszych przeglÄ…darek - wyÅ‚Ä…cz infinite scroll
                infiniteScrollEnabled.value = false;
              }
            } catch (err) {
              console.error('BÅ‚Ä…d podczas inicjalizacji aplikacji:', err);
            }
          });

          // Cleanup observer na unmount
          onBeforeUnmount(() => {
            if (intersectionObserver) {
              intersectionObserver.disconnect();
            }
            // Clear any pending save timers to prevent memory leaks
            if (saveTimer) {
              clearTimeout(saveTimer);
            }
          });

          // â”€â”€â”€ EDIT DRAWER (per-row) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          const editDrawer = ref({ open: false, row: null });
          const drawerSplitDate = ref('');
          const drawerError = ref('');
          const drawerLoading = ref(false);
          const drawerTab = ref('info'); // 'info' | 'split'

          const openDrawer = (row) => {
            editDrawer.value = { open: true, row };
            drawerTab.value = 'info';
            drawerError.value = '';
            drawerSplitDate.value = '';
          };

          const closeDrawer = () => {
            editDrawer.value = { open: false, row: null };
            drawerError.value = '';
          };

          const drawerSplitMin = computed(() => {
            const r = editDrawer.value.row;
            if (!r) return '';
            const d = new Date(r._start);
            d.setDate(d.getDate() + 1);
            return d.toISOString().slice(0, 10);
          });

          const drawerSplitMax = computed(() => {
            const r = editDrawer.value.row;
            if (!r) return '';
            const d = new Date(r._end);
            d.setDate(d.getDate() - 1);
            return d.toISOString().slice(0, 10);
          });

          const drawerConfirmSplit = async () => {
            if (!editDrawer.value.row || !drawerSplitDate.value) return;
            drawerError.value = '';
            drawerLoading.value = true;
            try {
              const res = await fetch('/ical/split', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  id: editDrawer.value.row.id,
                  splitDate: drawerSplitDate.value,
                }),
              });
              const data = await res.json();
              if (!data.success) throw new Error(data.error);
              closeDrawer();
              await fetchBookings(1);
            } catch (e) {
              drawerError.value = e.message;
            } finally {
              drawerLoading.value = false;
            }
          };

          const drawerUndoManual = async () => {
            const row = editDrawer.value.row;
            if (!row) return;
            drawerError.value = '';
            drawerLoading.value = true;
            try {
              const endpoint =
                row.manualType === 'merged' ? '/ical/undo-merge' : '/ical/undo-split';
              const res = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: row.id }),
              });
              const data = await res.json();
              if (!data.success) throw new Error(data.error);
              closeDrawer();
              await fetchBookings(1);
            } catch (e) {
              drawerError.value = e.message;
            } finally {
              drawerLoading.value = false;
            }
          };

          // â”€â”€â”€ MERGE MODE (select rows to merge) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          const editMode = ref(false); // kept as mergeMode toggle
          const selectedForMerge = ref([]);
          const editError = ref('');
          const editLoading = ref(false);

          const toggleEditMode = () => {
            editMode.value = !editMode.value;
            selectedForMerge.value = [];
            editError.value = '';
          };

          // kept for backward compat (split now via drawer)
          const splitTarget = ref(null);
          const splitDate = ref('');
          const openSplit = (row) => {
            openDrawer(row);
            drawerTab.value = 'split';
            const d = new Date(row._start);
            d.setDate(d.getDate() + 1);
            drawerSplitDate.value = d.toISOString().slice(0, 10);
          };
          const closeSplit = () => {
            drawerTab.value = 'info';
          };
          const confirmSplit = () => drawerConfirmSplit();
          const undoManual = (row) => {
            openDrawer(row);
          };

          const toggleSelectForMerge = (row) => {
            const idx = selectedForMerge.value.indexOf(row.id);
            if (idx > -1) {
              selectedForMerge.value.splice(idx, 1);
            } else {
              selectedForMerge.value.push(row.id);
            }
          };

          // Returns true when exactly 2 rows are selected AND they are adjacent (same property, end A = start B)
          // Uses local date comparison (sv-SE = YYYY-MM-DD in local timezone) to handle UTC offsets
          // correctly (e.g. iCal dates stored as 22:00Z = midnight CEST).
          const toLocalDate = (d) => new Date(d).toLocaleDateString('sv-SE');

          const canMerge = computed(() => {
            if (selectedForMerge.value.length !== 2) return false;
            const [r1, r2] = selectedForMerge.value.map((id) =>
              allRows.value.find((r) => r.id === id),
            );
            if (!r1 || !r2) return false;
            if (r1['NieruchomoÅ›Ä‡'] !== r2['NieruchomoÅ›Ä‡']) return false;
            const end1 = toLocalDate(r1._end);
            const start1 = toLocalDate(r1._start);
            const end2 = toLocalDate(r2._end);
            const start2 = toLocalDate(r2._start);
            return end1 === start2 || end2 === start1;
          });

          const mergeSelected = async () => {
            editError.value = '';
            editLoading.value = true;
            try {
              const res = await fetch('/ical/merge', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ids: selectedForMerge.value }),
              });
              const data = await res.json();
              if (!data.success) throw new Error(data.error);
              selectedForMerge.value = [];
              await fetchBookings(1);
            } catch (e) {
              editError.value = e.message;
            } finally {
              editLoading.value = false;
            }
          };

          // â”€â”€â”€ CONFLICT MODAL (po synchrnonizacji) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          const conflictModal = ref({ show: false, conflicts: [], resolved: {} });

          const openConflictModal = (conflicts) => {
            conflictModal.value = { show: true, conflicts, resolved: {} };
          };

          const setConflictDecision = (manualId, decision) => {
            conflictModal.value.resolved[manualId] = decision;
          };

          const resolveAllConflicts = async () => {
            editLoading.value = true;
            try {
              const { conflicts, resolved } = conflictModal.value;
              for (const c of conflicts) {
                const decision = resolved[c.manualBooking.id] || 'keep';
                await fetch('/ical/resolve-conflict', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ manualId: c.manualBooking.id, decision }),
                });
              }
              conflictModal.value.show = false;
              await fetchBookings(1);
            } catch (e) {
              editError.value = e.message;
            } finally {
              editLoading.value = false;
            }
          };
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

          return {
            loading,
            error,
            rows,
            allRows,
            filterParams,
            sortBy,
            displayedMonthLabel,
            fetchBookings,
            fetchData,
            loadMore,
            currentPage,
            pageSize,
            hasMore,
            totalCount,
            isLoadingMore,
            sentinelElement,
            infiniteScrollEnabled,
            newName,
            newUrl,
            newSource,
            properties,
            appendConfig,
            updateGuests,
            updateNotes,
            saving,
            from,
            to,
            setCurrentMonth,
            setPreviousMonth,
            setNextMonth,
            selectedApartments,
            apartmentNames,
            filteredRows,
            showApartmentDropdown,
            currentSummary,
            selectedGroup,
            groups,
            groupsWithCounts,
            selectedGroupData,
            newBookingsCount,
            syncing,
            backgroundSyncing,
            syncNow,
            syncProgress,
            showCancelled,
            modal,
            showModal,
            closeModal,
            removeApartment,
            toggleApartment,
            changingMonth,
            userRole,
            isAdmin,
            logout,
            editMode,
            toggleEditMode,
            selectedForMerge,
            toggleSelectForMerge,
            canMerge,
            mergeSelected,
            splitTarget,
            splitDate,
            openSplit,
            closeSplit,
            confirmSplit,
            undoManual,
            editError,
            editLoading,
            conflictModal,
            setConflictDecision,
            resolveAllConflicts,
            editDrawer,
            drawerTab,
            drawerSplitDate,
            drawerSplitMin,
            drawerSplitMax,
            drawerError,
            drawerLoading,
            openDrawer,
            closeDrawer,
            drawerConfirmSplit,
            drawerUndoManual,
          };
        },
        template: `
                <div>
                  <!-- Top Navigation -->
                  <nav class="topnav">
                    <a href="/" class="topnav-brand">ğŸ  BookingApp</a>
                    <div class="topnav-links">
                      <a href="/" class="active">Rezerwacje</a>
                      <a href="/calendar">ğŸ“… Kalendarz</a>
                      <a v-if="isAdmin" href="/config">âš™ Konfiguracja</a>
                    </div>
                    <div class="topnav-right">
                      <span v-if="isAdmin" class="topnav-role">ğŸ‘‘ Admin</span>
                      <span v-else class="topnav-role">ğŸ‘ PrzeglÄ…daj</span>
                      <a v-if="!isAdmin" href="/login" class="topnav-login">Zaloguj</a>
                      <button v-if="isAdmin" @click="logout" class="topnav-logout">Wyloguj</button>
                    </div>
                  </nav>

                  <div class="container">
                  <!-- Progress Bar for Sync -->
                  <div v-if="syncProgress.show" class="sync-progress-bar">
                    <div class="progress-container">
                      <p class="progress-message">{{ syncProgress.message }}</p>
                      <div class="progress-bar">
                        <div class="progress-fill" :style="{ width: syncProgress.percentage + '%' }"></div>
                      </div>
                      <span class="progress-percentage">{{ syncProgress.percentage }}%</span>
                    </div>
                  </div>

                  <h1>Rezerwacje</h1>

                  <!-- Group Selection Toolbar -->
                  <div class="toolbar mb-4">
                    <button
                      @click="selectedGroup = ''"
                      :class="['px-4 py-2 rounded', selectedGroup === '' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600']"
                    >
                      Wszystkie
                    </button>
                    <button
                      v-for="group in groupsWithCounts"
                      :key="group._id"
                      @click="selectedGroup = group._id"
                      :class="['px-4 py-2 rounded ml-2', selectedGroup === group._id ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600']"
                    >
                      {{ group.name }}
                      <span class="text-sm opacity-75">({{ group.propertyCount }} obj., {{ group.bookingCount }} rez.)</span>
                    </button>
                  </div>

                  <p style="display:flex; align-items:center; gap:10px;">Podsumowanie: {{ currentSummary }}
                    <span v-if="newBookingsCount > 0" class="new-badge">{{ newBookingsCount }} nowych</span>
                    <small v-if="backgroundSyncing" style="color:#ffd700; margin-left:8px; font-style:italic;">synchronizacja w tle...</small>
                  </p>

                  <!-- Main Controls Toolbar -->
                  <div class="main-toolbar">
                    <!-- Left Section: Filters -->
                    <div class="toolbar-section">
                      <div class="filter-group">
                        <label class="filter-label">Sortuj po:</label>
                        <select v-model="sortBy" class="filter-select">
                          <option value="start">przyjeÅºdzie</option>
                          <option value="end">wyjeÅºdzie</option>
                        </select>
                      </div>

                      <div class="filter-group">
                        <label class="filter-label">Od:</label>
                        <input type="date" v-model="from" class="filter-input"/>
                      </div>

                      <div class="filter-group">
                        <label class="filter-label">Do:</label>
                        <input type="date" v-model="to" class="filter-input"/>
                      </div>
                    </div>

                    <!-- Center Section: Quick Actions -->
                    <div class="toolbar-section">
                      <div class="button-group">
                        <button @click="setPreviousMonth" :disabled="changingMonth" class="action-button">{{ changingMonth ? 'â³' : 'â—€ Poprzedni' }}</button>
                        <button @click="setCurrentMonth" :disabled="changingMonth" class="action-button primary">{{ changingMonth ? 'ÅadujÄ™...' : 'Aktualny' }}</button>
                        <button @click="setNextMonth" :disabled="changingMonth" class="action-button">{{ changingMonth ? 'â³' : 'NastÄ™pny â–¶' }}</button>
                      </div>
                      <div class="month-label" style="margin-top:6px; text-align:center; color:#ddd; font-size:0.95rem;">
                        {{ displayedMonthLabel }}
                      </div>
                    </div>

                    <!-- Right Section: Main Actions -->
                    <div class="toolbar-section">
                      <div class="button-group">
                        <button @click="showCancelled = !showCancelled" :class="['action-button', showCancelled ? 'active' : '']">
                          {{ showCancelled ? 'Ukryj anulowane' : 'PokaÅ¼ anulowane' }}
                        </button>
                        <button
                          @click="filterParams.filterMode = filterParams.filterMode === 'sortBy' ? 'overlap' : 'sortBy'"
                          :class="['action-button', filterParams.filterMode === 'overlap' ? 'active' : '']"
                          title="Tryb filtrowania: 'WedÅ‚ug daty' pokazuje tylko rezerwacje z check-in/out w miesiÄ…cu. 'Wszystkie' pokazuje rezerwacje przecinajÄ…ce miesiÄ…c."
                        >
                          {{ filterParams.filterMode === 'overlap' ? 'ğŸ“… Wszystkie' : 'ğŸ“… WedÅ‚ug daty' }}
                        </button>
                        <button v-if="isAdmin" @click="syncNow" :disabled="syncing" class="action-button sync">
                          {{ syncing ? 'SynchronizujÄ™...' : 'Synchronizuj iCal' }}
                        </button>
                        <button v-if="isAdmin" @click="toggleEditMode" :class="['action-button merge-toggle-btn', editMode ? 'active' : '']"
                          title="Tryb scalania: zaznacz 2 sÄ…siadujÄ…ce rezerwacje tej samej nieruchomoÅ›ci">
                          {{ editMode ? 'âœ• ZakoÅ„cz scalanie' : 'ğŸ”— Scal rezerwacje' }}
                        </button>
                      </div>
                    </div>
                  </div>

                  <!-- Merge Mode Banner -->
                  <div v-if="editMode" class="edit-action-bar">
                    <span class="edit-mode-label">ğŸ”— Tryb scalania</span>
                    <span v-if="selectedForMerge.length === 0" class="edit-hint">Zaznacz 2 sÄ…siadujÄ…ce rezerwacje tej samej nieruchomoÅ›ci</span>
                    <span v-else-if="selectedForMerge.length === 1" class="edit-hint">Zaznacz jednÄ… wiÄ™cej ({{ selectedForMerge.length }}/2)</span>
                    <span v-else-if="selectedForMerge.length === 2 && !canMerge" class="edit-hint edit-hint-warn">âš ï¸ Rezerwacje muszÄ… byÄ‡ sÄ…siadujÄ…ce i tej samej nieruchomoÅ›ci</span>
                    <button v-if="canMerge" @click="mergeSelected" :disabled="editLoading" class="action-button merge-btn">
                      {{ editLoading ? 'Scalam...' : 'ğŸ”— Scal zaznaczone' }}
                    </button>
                    <span v-if="editError" class="edit-error">âŒ {{ editError }}</span>
                  </div>

      <div class="apartment-dropdown-container">
        <div
          class="apartment-select-trigger"
          @click="showApartmentDropdown = !showApartmentDropdown"
          tabindex="0"
          @blur="showApartmentDropdown = false"
        >
          <span v-if="!selectedApartments || !selectedApartments.length" class="placeholder">Filtruj nieruchomoÅ›ci</span>
          <span v-else-if="selectedApartments && selectedApartments.length">
            <span v-for="apt in selectedApartments" :key="apt" class="chip">{{ apt }} <button @click.stop="removeApartment(apt)">Ã—</button></span>
          </span>
          <span class="arrow">â–¼</span>
        </div>
        <div
          v-if="showApartmentDropdown"
          class="apartment-dropdown"
          @mousedown.prevent
        >
          <label v-for="name in apartmentNames" :key="name" class="apartment-option" @click.prevent="toggleApartment(name)">
            <input
              type="checkbox"
              :checked="selectedApartments.includes(name)"
              @click.prevent
            />
            {{ name }}
          </label>
        </div>
      </div>
                  <div class="card">
                    <div v-if="loading">Åadowanie...</div>
                    <div v-else-if="error">BÅ‚Ä…d: {{ error }}</div>
                    <div v-else>
                      <div style="overflow-x:auto;">
                        <table>
                          <thead>
                            <tr>
                              <th v-if="editMode"></th>
                              <th>NieruchomoÅ›Ä‡</th>
                              <th>Check-in</th>
                              <th>Check-out</th>
                              <th>Status wyjazdu</th>
                              <th>Liczba goÅ›ci</th>
                              <th>Notatki</th>
                              <th class="muted">Opis</th>
                              <th v-if="isAdmin" class="col-actions"></th>
                            </tr>
                          </thead>
                          <tbody>
                            <template v-for="r in filteredRows" :key="r.id || r._id">
                            <tr :class="{
                              'new-booking': r.isNew,
                              'cancelled-booking': r.cancellationStatus === 'cancelled' || r.cancellationStatus === true,
                              'manual-booking': r.isManual,
                              'selected-for-merge': selectedForMerge.includes(r.id)
                            }">
                              <td v-if="editMode" class="merge-checkbox-cell">
                                <input
                                  v-if="r.cancellationStatus !== 'cancelled' && (!r.isManual || r.manualType === 'block')"
                                  type="checkbox"
                                  :checked="selectedForMerge.includes(r.id)"
                                  @change="toggleSelectForMerge(r)"
                                  class="merge-checkbox"
                                />
                              </td>
                              <td>
                                {{ r['NieruchomoÅ›Ä‡'] }}
                                <span v-if="r.isNew" class="new-badge">NOWE</span>
                                <span v-if="r.isStartingToday" class="arrival-today-badge">PRZYJAZD</span>
                                <span v-if="r.cancellationStatus === 'cancelled' || r.cancellationStatus === true" class="cancelled-badge">ğŸš« ANULOWANA</span>
                                <span v-if="r.isManual && r.manualType === 'merged'" class="manual-badge merged-badge">ğŸ”€ SCALONE</span>
                                <span v-if="r.isManual && r.manualType === 'split'" class="manual-badge split-badge">âœ‚ PODZIELONE</span>
                              </td>
                              <td>{{ r['Data rozpoczÄ™cia'] }}</td>
                              <td>{{ r['Data zakoÅ„czenia'] }}</td>
                              <td>
                                <span :class="['badge', r['Status wyjazdu'] === 'PILNE' ? 'badge-pilne' : 'badge-normalne']">
                                  {{ r['Status wyjazdu'] }}
                                </span>
                              </td>
                              <td>
                                <input v-if="isAdmin" class="input input-small" type="number" min="0" max="20" v-model.number="r['Liczba goÅ›ci']" @input="updateGuests(r)" />
                                <span v-else>{{ r['Liczba goÅ›ci'] }}</span>
                              </td>
                              <td>
                                <input v-if="isAdmin" class="input input-medium" type="text" v-model="r['Notatki']" @input="updateNotes(r)" />
                                <span v-else>{{ r['Notatki'] }}</span>
                              </td>
                              <td class="muted opis-cell">{{ r['Opis'] }}</td>
                              <td v-if="isAdmin" class="col-actions">
                                <button
                                  @click="openDrawer(r)"
                                  class="row-edit-btn"
                                  title="Edytuj rezerwacjÄ™"
                                >âœï¸</button>
                              </td>
                            </tr>
                            </template>
                          </tbody>
                        </table>
                      </div>
                      <div class="footer">WskazÃ³wka: Status wyjazdu = "PILNE" oznacza przyjazd tego samego dnia. <span v-if="saving" class="saving-indicator">ZapisujÄ™...</span></div>

                      <!-- Infinite Scroll Sentinel Element -->
                      <div ref="sentinelElement" class="sentinel-element"></div>

                      <!-- Manual Load More Button (fallback for touch devices) -->
                      <div v-if="hasMore && !infiniteScrollEnabled" style="text-align:center; margin-top:12px;">
                        <button class="load-more-btn" @click="loadMore" :disabled="isLoadingMore">
                          {{ isLoadingMore ? 'ÅadujÄ™...' : 'ZaÅ‚aduj wiÄ™cej' }} ({{ allRows.length }} / {{ totalCount }})
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- â”€â”€ Edit Drawer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
                <transition name="drawer">
                  <div v-if="editDrawer.open" class="drawer-overlay" @click.self="closeDrawer">
                    <div class="drawer-panel" role="dialog" aria-modal="true">
                      <div class="drawer-header">
                        <div class="drawer-title">
                          <span class="drawer-property">{{ editDrawer.row?.['NieruchomoÅ›Ä‡'] }}</span>
                          <span class="drawer-dates">{{ editDrawer.row?.['Data rozpoczÄ™cia'] }} â€“ {{ editDrawer.row?.['Data zakoÅ„czenia'] }}</span>
                        </div>
                        <button class="drawer-close" @click="closeDrawer">âœ•</button>
                      </div>

                      <div class="drawer-tabs">
                        <button :class="['drawer-tab', drawerTab === 'info' ? 'active' : '']" @click="drawerTab = 'info'">ğŸ“‹ SzczegÃ³Å‚y</button>
                        <button
                          v-if="editDrawer.row && editDrawer.row.cancellationStatus !== 'cancelled' && (!editDrawer.row.isManual || editDrawer.row.manualType === 'block')"
                          :class="['drawer-tab', drawerTab === 'split' ? 'active' : '']"
                          @click="drawerTab = 'split'"
                        >âœ‚ Podziel</button>
                        <button
                          v-if="editDrawer.row?.isManual && (editDrawer.row.manualType === 'merged' || editDrawer.row.manualType === 'split')"
                          :class="['drawer-tab', drawerTab === 'undo' ? 'active' : '']"
                          @click="drawerTab = 'undo'"
                        >â†© Cofnij</button>
                      </div>

                      <div class="drawer-body">
                        <!-- Tab: Info -->
                        <div v-if="drawerTab === 'info'" class="drawer-section">
                          <div class="drawer-field">
                            <label class="drawer-label">Status wyjazdu</label>
                            <span :class="['badge', editDrawer.row?.['Status wyjazdu'] === 'PILNE' ? 'badge-pilne' : 'badge-normalne']">
                              {{ editDrawer.row?.['Status wyjazdu'] }}
                            </span>
                          </div>
                          <div class="drawer-field">
                            <label class="drawer-label">Liczba goÅ›ci</label>
                            <input
                              class="input drawer-input"
                              type="number" min="0" max="20"
                              v-model.number="editDrawer.row['Liczba goÅ›ci']"
                              @input="updateGuests(editDrawer.row)"
                            />
                          </div>
                          <div class="drawer-field">
                            <label class="drawer-label">Notatki</label>
                            <input
                              class="input drawer-input"
                              type="text"
                              v-model="editDrawer.row['Notatki']"
                              @input="updateNotes(editDrawer.row)"
                              placeholder="Dodaj notatkÄ™â€¦"
                            />
                          </div>
                          <div v-if="editDrawer.row?.['Opis']" class="drawer-field">
                            <label class="drawer-label">Opis (z platformy)</label>
                            <p class="drawer-desc">{{ editDrawer.row?.['Opis'] }}</p>
                          </div>
                          <div class="drawer-field">
                            <label class="drawer-label">Å¹rÃ³dÅ‚o</label>
                            <span class="drawer-value muted">{{ editDrawer.row?.source || 'manual' }}</span>
                          </div>
                        </div>

                        <!-- Tab: Split -->
                        <div v-if="drawerTab === 'split'" class="drawer-section">
                          <p class="drawer-hint">Podziel rezerwacjÄ™ na dwie osobne. Wybierz datÄ™, w ktÃ³rej nastÄ…pi podziaÅ‚ â€” pierwsza rezerwacja koÅ„czy siÄ™ w tej dacie, druga zaczyna.</p>
                          <div class="drawer-field">
                            <label class="drawer-label">Data podziaÅ‚u</label>
                            <input
                              type="date"
                              v-model="drawerSplitDate"
                              :min="drawerSplitMin"
                              :max="drawerSplitMax"
                              class="input drawer-input"
                            />
                          </div>
                          <div v-if="drawerSplitDate" class="split-preview">
                            <div class="split-preview-item">
                              <span class="split-preview-label">CzÄ™Å›Ä‡ 1</span>
                              <span>{{ editDrawer.row?.['Data rozpoczÄ™cia'] }} â†’ {{ drawerSplitDate }}</span>
                            </div>
                            <div class="split-preview-item">
                              <span class="split-preview-label">CzÄ™Å›Ä‡ 2</span>
                              <span>{{ drawerSplitDate }} â†’ {{ editDrawer.row?.['Data zakoÅ„czenia'] }}</span>
                            </div>
                          </div>
                          <span v-if="drawerError" class="edit-error">âŒ {{ drawerError }}</span>
                          <div class="drawer-actions">
                            <button
                              @click="drawerConfirmSplit"
                              :disabled="drawerLoading || !drawerSplitDate"
                              class="action-button primary drawer-action-btn"
                            >{{ drawerLoading ? 'DzielÄ™...' : 'âœ‚ Podziel' }}</button>
                          </div>
                        </div>

                        <!-- Tab: Undo -->
                        <div v-if="drawerTab === 'undo'" class="drawer-section">
                          <p class="drawer-hint">
                            Ta rezerwacja zostaÅ‚a
                            <strong>{{ editDrawer.row?.manualType === 'merged' ? 'scalona' : 'podzielona' }}</strong>
                            rÄ™cznie. MoÅ¼esz cofnÄ…Ä‡ tÄ™ operacjÄ™ i przywrÃ³ciÄ‡ oryginalne rezerwacje.
                          </p>
                          <span v-if="drawerError" class="edit-error">âŒ {{ drawerError }}</span>
                          <div class="drawer-actions">
                            <button
                              @click="drawerUndoManual"
                              :disabled="drawerLoading"
                              class="action-button drawer-action-btn undo-action-btn"
                            >{{ drawerLoading ? 'Cofam...' : 'â†© Cofnij operacjÄ™' }}</button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </transition>

                <!-- Modal -->
                <div class="modal-overlay" :class="{ active: modal.show }" @click="closeModal">
                  <div class="modal-content" @click.stop>
                    <div class="modal-header">
                      <h3 class="modal-title">{{ modal.title }}</h3>
                      <button class="modal-close" @click="closeModal">&times;</button>
                    </div>
                    <div class="modal-body">
                      <p>{{ modal.message }}</p>
                      <div v-if="modal.stats" class="modal-stats">
                        <div v-for="(value, key) in modal.stats" :key="key" class="modal-stat">
                          <span class="modal-stat-label">{{ key }}:</span>
                          <span class="modal-stat-value">{{ value }}</span>
                        </div>
                      </div>
                    </div>
                    <div class="modal-actions">
                      <button class="modal-btn modal-btn-primary" @click="closeModal">OK</button>
                    </div>
                  </div>
                </div>

                <!-- Conflict Modal -->
                <div class="modal-overlay" :class="{ active: conflictModal.show }">
                  <div class="modal-content modal-content-wide" @click.stop>
                    <div class="modal-header">
                      <h3 class="modal-title">âš ï¸ Konflikty synchronizacji</h3>
                    </div>
                    <div class="modal-body">
                      <p style="margin-bottom:12px">Synchronizacja wykryÅ‚a Å¼e nastÄ™pujÄ…ce rÄ™cznie edytowane rezerwacje nakÅ‚adajÄ… siÄ™ z danymi z iCal. Zdecyduj co zrobiÄ‡ z kaÅ¼dÄ… z nich:</p>
                      <div v-for="c in conflictModal.conflicts" :key="c.manualBooking.id" class="conflict-item">
                        <div class="conflict-info">
                          <span class="conflict-property">{{ c.manualBooking.propertyName }}</span>
                          <span class="conflict-dates">{{ new Date(c.manualBooking.start).toLocaleDateString('pl-PL') }} â€“ {{ new Date(c.manualBooking.end).toLocaleDateString('pl-PL') }}</span>
                          <span :class="['manual-badge', c.manualBooking.manualType === 'merged' ? 'merged-badge' : 'split-badge']">
                            {{ c.manualBooking.manualType === 'merged' ? 'ğŸ”€ SCALONE' : 'âœ‚ PODZIELONE' }}
                          </span>
                          <span class="conflict-reason">{{ c.reason }}</span>
                        </div>
                        <div class="conflict-ical-info">
                          <div v-for="ch in c.changedOriginals" :key="ch.uid" style="margin-bottom:4px">
                            <small>
                              <b>Zmiana w iCal:</b>
                              <span style="text-decoration:line-through;color:#999">{{ ch.snapshotStart }} â€“ {{ ch.snapshotEnd }}</span>
                              â†’ <span style="color:#d97706;font-weight:600">{{ ch.newStart }} â€“ {{ ch.newEnd }}</span>
                            </small>
                          </div>
                        </div>
                        <div class="conflict-actions">
                          <button
                            @click="setConflictDecision(c.manualBooking.id, 'keep')"
                            :class="['action-button', conflictModal.resolved[c.manualBooking.id] === 'keep' || !conflictModal.resolved[c.manualBooking.id] ? 'primary' : '']"
                          >âœ… Zachowaj mojÄ…</button>
                          <button
                            @click="setConflictDecision(c.manualBooking.id, 'remove')"
                            :class="['action-button', conflictModal.resolved[c.manualBooking.id] === 'remove' ? 'active' : '']"
                          >ğŸ—‘ UsuÅ„, weÅº z iCal</button>
                        </div>
                      </div>
                    </div>
                    <div class="modal-actions">
                      <button class="modal-btn modal-btn-primary" @click="resolveAllConflicts" :disabled="editLoading">
                        {{ editLoading ? 'ZapisujÄ™...' : 'ZatwierdÅº decyzje' }}
                      </button>
                    </div>
                  </div>
                </div>
                </div>
              `,
      }).mount('#app');
    </script>
  </body>
</html>
