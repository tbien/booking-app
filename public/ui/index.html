<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rezerwacje (iCal)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <!-- App Container -->
    <main id="app"></main>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script>
      const { createApp, ref, computed, onMounted, watch } = Vue;
      createApp({
        setup() {
          const loading = ref(true);
          const error = ref('');
          const rows = ref([]);
          const daysAhead = ref(35);
          const sortBy = ref('end');
          const from = ref('');
          const to = ref('');
          const newName = ref('');
          const newUrl = ref('');
          const newSource = ref('');
          const appendConfig = ref(true);
          const properties = ref([]);
          const saving = ref(false);
          let saveTimer = null;

          const propertiesWithCosts = ref([]);

          // Helper function to map raw booking data to standardized format
          const mapBookingData = (rawRows) => {
            return (rawRows || []).map((it) => {
              // Backend already returns data in the correct format, just pass it through
              return {
                ...it,
                // Ensure all required fields exist with fallbacks
                Nieruchomość: it['Nieruchomość'] || it.propertyName || 'Nieznana',
                'Data rozpoczęcia':
                  it['Data rozpoczęcia'] ||
                  (it.start ? new Date(it.start).toLocaleDateString('pl-PL') : ''),
                'Data zakończenia':
                  it['Data zakończenia'] ||
                  (it.end ? new Date(it.end).toLocaleDateString('pl-PL') : ''),
                'Status wyjazdu':
                  it['Status wyjazdu'] ||
                  (typeof it.isUrgentChangeover === 'boolean'
                    ? it.isUrgentChangeover
                      ? 'PILNE'
                      : 'NORMALNE'
                    : 'NORMALNE'),
                Opis: it['Opis'] || it.description || '',
                Źródło: it['Źródło'] || it.source || '',
                'Liczba gości':
                  it['Liczba gości'] !== undefined
                    ? it['Liczba gości']
                    : typeof it.guests === 'number'
                    ? it.guests
                    : '',
                Notatki: it['Notatki'] || it.notes || '',
                id: it.id || it._id || '',
                groupId: it.groupId || null,
                isNew: it.isNew || false,
                isStartingToday: it.isStartingToday || false,
                createdAt: it.createdAt,
                updatedAt: it.updatedAt,
              };
            });
          };

          const selectedApartments = ref([]);

          const showApartmentDropdown = ref(false);

          const selectedGroup = ref('');

          const groups = ref([]);

          const showCancelled = ref(false);

          const modal = ref({
            show: false,
            title: '',
            message: '',
            stats: null,
          });

          const apartmentNames = computed(() => {
            // Unique apartment names from all rows
            if (!rows.value || !Array.isArray(rows.value)) return [];
            const names = rows.value.map((r) => r['Nieruchomość']);
            return [...new Set(names)].sort();
          });

          const filteredRows = computed(() => {
            let filtered = rows.value;
            if (selectedGroup.value) {
              filtered = filtered.filter((row) => row.groupId === selectedGroup.value);
            }
            if (selectedApartments.value.length > 0) {
              filtered = filtered.filter((r) =>
                selectedApartments.value.includes(r['Nieruchomość']),
              );
            }
            return filtered;
          });

          const currentSummary = computed(() => {
            const propMap = new Map(
              propertiesWithCosts.value.map((p) => [p.name, p.cleaningCost || 0]),
            );
            let total = 0;
            filteredRows.value.forEach((row) => {
              total += propMap.get(row['Nieruchomość']) || 0;
            });
            const bookingCount = filteredRows.value.length;
            const uniqueProperties = new Set(filteredRows.value.map((row) => row['Nieruchomość']));

            let summary = `${bookingCount} rezerwacji`;
            if (uniqueProperties.size > 0) {
              summary += `, ${uniqueProperties.size} nieruchomości`;
            }
            if (total > 0) {
              summary += `, ${total} PLN`;
            }

            return summary;
          });

          const groupsWithCounts = computed(() => {
            return groups.value.map((group) => {
              const groupRows = rows.value.filter((row) => row.groupId === group._id);
              return {
                ...group,
                propertyCount: group.propertyCount || 0, // Use count from backend
                bookingCount: groupRows.length,
              };
            });
          });

          const selectedGroupData = computed(() => {
            if (!selectedGroup.value) return null;
            return groupsWithCounts.value.find((g) => g._id === selectedGroup.value);
          });

          const removeApartment = (apt) => {
            selectedApartments.value = selectedApartments.value.filter((a) => a !== apt);
          };

          const toggleApartment = (apt) => {
            const index = selectedApartments.value.indexOf(apt);
            if (index > -1) {
              selectedApartments.value.splice(index, 1);
            } else {
              selectedApartments.value.push(apt);
            }
          };

          const newBookingsCount = computed(() => {
            return filteredRows.value.filter((row) => row.isNew).length;
          });

          const fetchData = async () => {
            loading.value = true;
            error.value = '';
            try {
              const params = new URLSearchParams({
                daysAhead: String(daysAhead.value),
                sortBy: String(sortBy.value),
              });
              if (from.value) params.set('from', from.value);
              if (to.value) params.set('to', to.value);
              if (showCancelled.value) params.set('includeCancelled', 'true');
              const res = await fetch(`/ical/data?${params.toString()}`);
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'Błąd');
              rows.value = mapBookingData(data.rows);
            } catch (e) {
              error.value = e.message || 'Błąd';
            } finally {
              loading.value = false;
            }
          };

          const updateGuests = async (row) => {
            if (!row.id) return;
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(async () => {
              try {
                saving.value = true;
                await fetch('/ical/guests', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    id: row.id,
                    guests: Number(row['Liczba gości'] || 0),
                  }),
                });
              } catch (e) {
                console.error(e);
              } finally {
                saving.value = false;
              }
            }, 500);
          };

          const updateNotes = async (row) => {
            if (!row.id) return;
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(async () => {
              try {
                saving.value = true;
                await fetch('/ical/notes', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    id: row.id,
                    notes: row['Notatki'] || '',
                  }),
                });
              } catch (e) {
                console.error(e);
              } finally {
                saving.value = false;
              }
            }, 500);
          };

          // Helper that formats a Date to local YYYY-MM-DD
          const formatLocalDate = (d) => {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
          };

          // Returns start/end Date objects for month offset from current (0 = current month, -1 = previous)
          const getMonthRange = (offsetMonths = 0) => {
            const now = new Date();
            const start = new Date(now.getFullYear(), now.getMonth() + offsetMonths, 1);
            const end = new Date(now.getFullYear(), now.getMonth() + offsetMonths + 1, 0);
            return { start, end };
          };

          const setMonthByOffset = (offsetMonths) => {
            const { start, end } = getMonthRange(offsetMonths);
            from.value = formatLocalDate(start);
            to.value = formatLocalDate(end);
            // Reset filters when changing date range to show all data
            selectedGroup.value = '';
            selectedApartments.value = [];
            fetchData();
          };

          const setCurrentMonth = () => setMonthByOffset(0);

          const setPreviousMonth = () => setMonthByOffset(-1);

          const setNextMonth = () => setMonthByOffset(1);

          const fetchProperties = async () => {
            try {
              const res = await fetch('/ical/properties');
              const data = await res.json();
              // Group properties by name and take the cleaning cost from any source (they should be the same for logical property)
              const propMap = new Map();
              data.properties.forEach((p) => {
                if (!propMap.has(p.name)) {
                  propMap.set(p.name, { cleaningCost: p.cleaningCost || 0, sources: [] });
                }
                propMap.get(p.name).sources.push(p.source);
              });
              propertiesWithCosts.value = Array.from(propMap.entries()).map(([name, data]) => ({
                name,
                cleaningCost: data.cleaningCost,
                sources: data.sources,
              }));
            } catch (e) {
              console.error('Failed to fetch properties:', e);
            }
          };

          // Watch for showCancelled changes and refresh data
          watch(showCancelled, async () => {
            await fetchData();
          });

          // Watch for apartment selection changes and refresh data
          watch(
            selectedApartments,
            async (newSelection) => {
              // No need to refresh data - filtering is done on frontend
            },
            { deep: true },
          );

          // Watch for filter changes and refresh data
          watch(daysAhead, async () => {
            await fetchData();
          });

          watch(from, async () => {
            await fetchData();
          });

          watch(to, async () => {
            await fetchData();
          });

          watch(sortBy, async () => {
            await fetchData();
          });

          const fetchGroups = async () => {
            try {
              const res = await fetch('/ical/groups');
              const data = await res.json();
              groups.value = data.groups;
            } catch (e) {
              console.error('Failed to fetch groups:', e);
            }
          };

          const currentPage = ref(1);
          const hasMore = ref(false);
          const totalCount = ref(0);

          const fetchAllData = async (page = 1) => {
            loading.value = true;
            error.value = '';
            try {
              const params = new URLSearchParams({
                sortBy: String(sortBy.value),
                all: 'true',
                page: String(page),
                limit: '30',
              });
              const res = await fetch(`/ical/data?${params.toString()}`);
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'Błąd');
              if (page === 1) {
                rows.value = mapBookingData(data.rows);
              } else {
                rows.value.push(...mapBookingData(data.rows));
              }
              currentPage.value = page;
              hasMore.value = data.hasMore;
              totalCount.value = data.totalCount;
            } catch (e) {
              error.value = e.message || 'Błąd';
            } finally {
              loading.value = false;
            }
          };

          const loadMore = () => {
            fetchAllData(currentPage.value + 1);
          };

          const syncing = ref(false);

          const syncNow = async () => {
            syncing.value = true;
            try {
              const syncData = {
                daysAhead: daysAhead.value,
              };
              if (selectedGroup.value) {
                syncData.groupId = selectedGroup.value;
              }
              if (selectedApartments.value.length > 0) {
                syncData.propertyNames = selectedApartments.value.join(',');
              }

              const res = await fetch('/ical/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(syncData),
              });
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'Sync failed');

              // Refresh data after sync
              await fetchData();

              // Show success modal
              showModal('Synchronizacja zakończona!', data.message, data.stats);
            } catch (e) {
              showModal('Błąd synchronizacji', e.message, null);
            } finally {
              syncing.value = false;
            }
          };

          const showModal = (title, message, stats = null) => {
            // Translate stats keys to Polish
            const translatedStats = stats
              ? {
                  'Zsynchronizowane nieruchomości': stats.propertiesSynced,
                  'Zaktualizowane rezerwacje': stats.bookingsUpdated,
                  'Anulowane rezerwacje': stats.bookingsCancelled,
                }
              : null;

            modal.value = {
              show: true,
              title,
              message,
              stats: translatedStats,
            };
          };

          const closeModal = () => {
            modal.value.show = false;
          };

          // Load initial data when component mounts
          onMounted(async () => {
            await fetchAllData();
            await fetchProperties();
            await fetchGroups();
          });

          return {
            loading,
            error,
            rows,
            daysAhead,
            sortBy,
            fetchData,
            fetchAllData,
            loadMore,
            currentPage,
            hasMore,
            totalCount,
            newName,
            newUrl,
            newSource,
            properties,
            appendConfig,
            updateGuests,
            updateNotes,
            saving,
            from,
            to,
            setCurrentMonth,
            setPreviousMonth,
            setNextMonth,
            selectedApartments,
            apartmentNames,
            filteredRows,
            showApartmentDropdown,
            currentSummary,
            selectedGroup,
            groups,
            groupsWithCounts,
            selectedGroupData,
            newBookingsCount,
            syncing,
            syncNow,
            showCancelled,
            modal,
            showModal,
            closeModal,
            removeApartment,
            toggleApartment,
          };
        },
        template: `
          <div class="container">
            <a href="/config" class="config-button">Konfiguracja iCal</a>
            <h1>Rezerwacje (następne 35 dni)</h1>
            
            <!-- Group Selection Toolbar -->
            <div class="toolbar mb-4">
              <button 
                @click="selectedGroup = ''" 
                :class="['px-4 py-2 rounded', selectedGroup === '' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600']"
              >
                Wszystkie
              </button>
              <button 
                v-for="group in groupsWithCounts" 
                :key="group._id" 
                @click="selectedGroup = group._id" 
                :class="['px-4 py-2 rounded ml-2', selectedGroup === group._id ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600']"
              >
                {{ group.name }} 
                <span class="text-sm opacity-75">({{ group.propertyCount }} obj., {{ group.bookingCount }} rez.)</span>
              </button>
            </div>

            <p>Podsumowanie: {{ currentSummary }}
              <span v-if="newBookingsCount > 0" class="new-badge">{{ newBookingsCount }} nowych</span>
            </p>

            <!-- Main Controls Toolbar -->
            <div class="main-toolbar">
              <!-- Left Section: Filters -->
              <div class="toolbar-section">
                <div class="filter-group">
                  <label class="filter-label">Zakres dni:</label>
                  <input type="number" min="1" max="365" v-model.number="daysAhead" class="filter-input"/>
                </div>

                <div class="filter-group">
                  <label class="filter-label">Sortuj po:</label>
                  <select v-model="sortBy" class="filter-select">
                    <option value="start">przyjeździe</option>
                    <option value="end">wyjeździe</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label class="filter-label">Od:</label>
                  <input type="date" v-model="from" class="filter-input"/>
                </div>

                <div class="filter-group">
                  <label class="filter-label">Do:</label>
                  <input type="date" v-model="to" class="filter-input"/>
                </div>
              </div>

              <!-- Center Section: Quick Actions -->
              <div class="toolbar-section">
                <div class="button-group">
                  <button @click="setPreviousMonth" class="action-button">◀ Poprzedni</button>
                  <button @click="setCurrentMonth" class="action-button primary">Aktualny</button>
                  <button @click="setNextMonth" class="action-button">Następny ▶</button>
                </div>
              </div>

              <!-- Right Section: Main Actions -->
              <div class="toolbar-section">
                <div class="button-group">
                  <button @click="showCancelled = !showCancelled" :class="['action-button', showCancelled ? 'active' : '']">
                    {{ showCancelled ? 'Ukryj anulowane' : 'Pokaż anulowane' }}
                  </button>
                  <button @click="syncNow" :disabled="syncing" class="action-button sync">
                    {{ syncing ? 'Synchronizuję...' : 'Synchronizuj iCal' }}
                  </button>
                </div>
              </div>
            </div>
<div class="apartment-dropdown-container">
  <div
    class="apartment-select-trigger"
    @click="showApartmentDropdown = !showApartmentDropdown"
    tabindex="0"
    @blur="showApartmentDropdown = false"
  >
    <span v-if="!selectedApartments || !selectedApartments.length" class="placeholder">Filtruj nieruchomości</span>
    <span v-else-if="selectedApartments && selectedApartments.length">
      <span v-for="apt in selectedApartments" :key="apt" class="chip">{{ apt }} <button @click.stop="removeApartment(apt)">×</button></span>
    </span>
    <span class="arrow">▼</span>
  </div>
  <div
    v-if="showApartmentDropdown"
    class="apartment-dropdown"
    @mousedown.prevent
  >
    <label v-for="name in apartmentNames" :key="name" @click="toggleApartment(name)">
      <input
        type="checkbox"
        :value="name"
        v-model="selectedApartments"
        @click.stop
      />
      {{ name }}
    </label>
  </div>
</div>
            <div class="card">
              <div v-if="loading">Ładowanie...</div>
              <div v-else-if="error">Błąd: {{ error }}</div>
              <div v-else>
                <div style="overflow-x:auto;">
                  <table>
                    <thead>
                      <tr>
                        <th>Nieruchomość</th>
                        <th>Check-in</th>
                        <th>Check-out</th>
                        <th>Status wyjazdu</th>
                        <th>Liczba gości</th>
                        <th>Notatki</th>
                        <th class="muted">Opis</th>
                        <th class="muted">Źródło</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr v-for="(r, idx) in filteredRows" :key="idx" :class="{ 'new-booking': r.isNew, 'cancelled-booking': r.cancellationStatus === 'cancelled' || r.cancellationStatus === true }">
                        <td>
                          {{ r['Nieruchomość'] }}
                          <span v-if="r.isNew" class="new-badge">NOWE</span>
                          <span v-if="r.isStartingToday" class="arrival-today-badge">PRZYJAZD</span>
                          <span v-if="r.cancellationStatus === 'cancelled' || r.cancellationStatus === true" class="cancelled-badge">🚫 ANULOWANA</span>
                        </td>
                        <td>{{ r['Data rozpoczęcia'] }}</td>
                        <td>{{ r['Data zakończenia'] }}</td>
                        <td>
                          <span :class="['badge', r['Status wyjazdu'] === 'PILNE' ? 'badge-pilne' : 'badge-normalne']">
                            {{ r['Status wyjazdu'] }}
                          </span>
                        </td>
                        <td>
                          <input class="input input-small" type="number" min="0" max="20" v-model.number="r['Liczba gości']" @input="updateGuests(r)" />
                        </td>
                        <td>
                          <input class="input input-medium" type="text" v-model="r['Notatki']" @input="updateNotes(r)" />
                        </td>
                        <td class="muted opis-cell">{{ r['Opis'] }}</td>
                        <td class="muted"><a :href="r['Źródło']" target="_blank">źródło</a></td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="footer">Wskazówka: Status wyjazdu = "PILNE" oznacza przyjazd tego samego dnia. <span v-if="saving" class="saving-indicator">Zapisuję...</span></div>
                <div v-if="hasMore" style="text-align:center; margin-top:12px;">
                  <button class="load-more-btn" @click="loadMore">
                    {{"Załaduj więcej"}} ({{ currentPage * 30 }} z {{ totalCount }})
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Modal -->
          <div class="modal-overlay" :class="{ active: modal.show }" @click="closeModal">
            <div class="modal-content" @click.stop>
              <div class="modal-header">
                <h3 class="modal-title">{{ modal.title }}</h3>
                <button class="modal-close" @click="closeModal">&times;</button>
              </div>
              <div class="modal-body">
                <p>{{ modal.message }}</p>
                <div v-if="modal.stats" class="modal-stats">
                  <div v-for="(value, key) in modal.stats" :key="key" class="modal-stat">
                    <span class="modal-stat-label">{{ key }}:</span>
                    <span class="modal-stat-value">{{ value }}</span>
                  </div>
                </div>
              </div>
              <div class="modal-actions">
                <button class="modal-btn modal-btn-primary" @click="closeModal">OK</button>
              </div>
            </div>
          </div>
        `,
      }).mount('#app');
    </script>
  </body>
</html>
