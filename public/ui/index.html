<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rezerwacje (iCal)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <!-- App Container -->
    <main id="app"></main>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
      const { createApp, ref, computed, onMounted, watch, onBeforeUnmount } = Vue;
      createApp({
        setup() {
          const loading = ref(true);
          const error = ref('');
          const rows = ref([]); // Keep for backward compatibility, will sync with allRows
          const newName = ref('');
          const newUrl = ref('');
          const newSource = ref('');
          const appendConfig = ref(true);
          const properties = ref([]);
          const saving = ref(false);
          let saveTimer = null;

          // Rola u≈ºytkownika (null = jeszcze nieznana, 'user' = niezalogowany, 'admin' = zalogowany)
          const userRole = ref(null);
          const isAdmin = computed(() => userRole.value === 'admin');

          const fetchRole = async () => {
            try {
              const res = await fetch('/auth/me');
              const data = await res.json();
              userRole.value = data.role || 'user';
            } catch {
              userRole.value = 'user';
            }
          };

          const logout = async () => {
            await fetch('/auth/logout', { method: 'POST' });
            userRole.value = 'user';
            window.location.reload();
          };

          // Helper to format date as YYYY-MM-DD
          const formatDate = (date) => {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
          };

          // Calculate default dates: current month (1st to last day) + next month
          const now = new Date();
          const defaultStart = new Date(now.getFullYear(), now.getMonth(), 1); // 1st of current month
          const defaultEnd = new Date(now.getFullYear(), now.getMonth() + 2, 0); // Last day of next month

          // Centralized filter params - MUST be defined early before changeMonth()
          const filterParams = ref({
            filterMode: localStorage.getItem('filterMode') || 'sortBy',
            sortBy: 'end',
            from: formatDate(defaultStart),
            to: formatDate(defaultEnd),
            searchText: '',
            groupId: '',
            propertyId: '',
            limit: 50,
            page: 1,
            showCancelled: false,
          }); // Sync state flag
          const syncing = ref(false);

          const propertiesWithCosts = ref([]);

          // Helper function to map raw booking data to standardized format
          const mapBookingData = (rawRows) => {
            return (rawRows || []).map((it) => {
              // Backend already returns data in the correct format, just pass it through
              return {
                ...it,
                // Ensure all required fields exist with fallbacks
                Nieruchomo≈õƒá: it['Nieruchomo≈õƒá'] || it.propertyName || 'Nieznana',
                'Data rozpoczƒôcia':
                  it['Data rozpoczƒôcia'] ||
                  (it.start ? new Date(it.start).toLocaleDateString('pl-PL') : ''),
                'Data zako≈Ñczenia':
                  it['Data zako≈Ñczenia'] ||
                  (it.end ? new Date(it.end).toLocaleDateString('pl-PL') : ''),
                'Status wyjazdu':
                  it['Status wyjazdu'] ||
                  (typeof it.isUrgentChangeover === 'boolean'
                    ? it.isUrgentChangeover
                      ? 'PILNE'
                      : 'NORMALNE'
                    : 'NORMALNE'),
                Opis: it['Opis'] || it.description || '',
                ≈πr√≥d≈Ço: it['≈πr√≥d≈Ço'] || it.source || '',
                'Liczba go≈õci':
                  it['Liczba go≈õci'] !== undefined
                    ? it['Liczba go≈õci']
                    : typeof it.guests === 'number'
                    ? it.guests
                    : '',
                Notatki: it['Notatki'] || it.notes || '',
                id: it.id || it._id || '',
                groupId: it.groupId || null,
                isNew: it.isNew || false,
                isStartingToday: it.isStartingToday || false,
                createdAt: it.createdAt,
                updatedAt: it.updatedAt,
                _start: it._start,
                _end: it._end,
              };
            });
          };

          const selectedApartments = ref([]);

          const showApartmentDropdown = ref(false);

          const selectedGroup = ref('');

          const groups = ref([]);

          const showCancelled = ref(false);

          // Progress synchronizacji
          const syncProgress = ref({
            show: false,
            status: '', // 'fetching', 'syncing', 'done'
            percentage: 0,
            message: '',
          });

          // Flaga aby sync siƒô uruchomi≈Ç tylko raz
          let autoSyncDone = false;

          // Background sync indicator (lightweight UI when sync runs in background)
          const backgroundSyncing = ref(false);

          const modal = ref({
            show: false,
            title: '',
            message: '',
            stats: null,
          });

          const apartmentNames = computed(() => {
            // Unique apartment names from all rows
            if (!rows.value || !Array.isArray(rows.value)) return [];
            const names = rows.value.map((r) => r['Nieruchomo≈õƒá']);
            return [...new Set(names)].sort();
          });

          const filteredRows = computed(() => {
            let filtered = allRows.value;
            if (selectedGroup.value) {
              filtered = filtered.filter((row) => row.groupId === selectedGroup.value);
            }
            if (selectedApartments.value.length > 0) {
              filtered = filtered.filter((r) =>
                selectedApartments.value.includes(r['Nieruchomo≈õƒá']),
              );
            }
            // Sortowanie frontendowe po dacie przyjazdu lub wyjazdu
            const key = filterParams.value.sortBy === 'start' ? '_start' : '_end';
            filtered = [...filtered].sort((a, b) => {
              const da = a[key] ? new Date(a[key]).getTime() : 0;
              const db = b[key] ? new Date(b[key]).getTime() : 0;
              return da - db;
            });
            return filtered;
          });

          const currentSummary = computed(() => {
            const propMap = new Map(
              propertiesWithCosts.value.map((p) => [p.name, p.cleaningCost || 0]),
            );
            let total = 0;
            filteredRows.value.forEach((row) => {
              total += propMap.get(row['Nieruchomo≈õƒá']) || 0;
            });
            const bookingCount = filteredRows.value.length;
            const uniqueProperties = new Set(filteredRows.value.map((row) => row['Nieruchomo≈õƒá']));

            let summary = `${bookingCount} rezerwacji`;
            if (uniqueProperties.size > 0) {
              summary += `, ${uniqueProperties.size} nieruchomo≈õci`;
            }
            if (total > 0) {
              summary += `, ${total} PLN`;
            }

            return summary;
          });

          const groupsWithCounts = computed(() => {
            return groups.value.map((group) => {
              const groupRows = rows.value.filter((row) => row.groupId === group._id);
              return {
                ...group,
                propertyCount: group.propertyCount || 0, // Use count from backend
                bookingCount: groupRows.length,
              };
            });
          });

          const selectedGroupData = computed(() => {
            if (!selectedGroup.value) return null;
            return groupsWithCounts.value.find((g) => g._id === selectedGroup.value);
          });

          const removeApartment = (apt) => {
            selectedApartments.value = selectedApartments.value.filter((a) => a !== apt);
          };

          const toggleApartment = (apt) => {
            const index = selectedApartments.value.indexOf(apt);
            if (index > -1) {
              selectedApartments.value.splice(index, 1);
            } else {
              selectedApartments.value.push(apt);
            }
          };

          const newBookingsCount = computed(() => {
            return filteredRows.value.filter((row) => row.isNew).length;
          });

          // Computed refs for backward compatibility with template
          const sortBy = computed({
            get: () => filterParams.value.sortBy,
            set: (val) => {
              filterParams.value.sortBy = val;
            },
          });
          const from = computed({
            get: () => filterParams.value.from,
            set: (val) => {
              filterParams.value.from = val;
            },
          });
          const to = computed({
            get: () => filterParams.value.to,
            set: (val) => {
              filterParams.value.to = val;
            },
          });

          const fetchData = async () => {
            loading.value = true;
            error.value = '';
            try {
              const params = new URLSearchParams({
                sortBy: String(filterParams.value.sortBy),
              });

              // Always send from/to dates
              if (filterParams.value.from) params.set('from', filterParams.value.from);
              if (filterParams.value.to) params.set('to', filterParams.value.to);
              if (showCancelled.value) params.set('includeCancelled', 'true');

              const res = await fetch(`/ical/data?${params.toString()}`);
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'B≈ÇƒÖd');
              rows.value = mapBookingData(data.rows);
            } catch (e) {
              error.value = e.message || 'B≈ÇƒÖd';
            } finally {
              loading.value = false;
            }
          };

          const updateGuests = async (row) => {
            if (!row.id) return;
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(async () => {
              try {
                saving.value = true;
                await fetch('/ical/guests', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    id: row.id,
                    guests: Number(row['Liczba go≈õci'] || 0),
                  }),
                });
              } catch (e) {
                console.error(e);
              } finally {
                saving.value = false;
              }
            }, 500);
          };

          const updateNotes = async (row) => {
            if (!row.id) return;
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(async () => {
              try {
                saving.value = true;
                await fetch('/ical/notes', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    id: row.id,
                    notes: row['Notatki'] || '',
                  }),
                });
              } catch (e) {
                console.error(e);
              } finally {
                saving.value = false;
              }
            }, 500);
          };

          // Helper that formats a Date to local YYYY-MM-DD
          const formatLocalDate = (d) => {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
          };

          // Returns start/end Date objects for month offset from current (0 = current month, -1 = previous)
          const getMonthRange = (offsetMonths = 0) => {
            const now = new Date();
            const start = new Date(now.getFullYear(), now.getMonth() + offsetMonths, 1);
            const end = new Date(now.getFullYear(), now.getMonth() + offsetMonths + 1, 0);
            return { start, end };
          };

          // KROK 1: Nowa funkcja changeMonth - wywo≈Ça fetchBookings bezpo≈õrednio, bez debounce
          const changeMonth = async () => {
            // Direct fetch without debounce - used by setMonthByOffset
            changingMonth.value = true;
            currentPage.value = 1;
            allRows.value = [];
            rows.value = [];
            await fetchBookings(1);
            changingMonth.value = false;
          };

          // Track currently displayed month as an offset from 'now'.
          // This allows multiple clicks on Next/Previous to accumulate the offset
          // instead of always jumping to "now + 1".
          const currentMonthOffset = ref(0);

          // Apply a delta (e.g. +1 or -1) to the current month offset and reload.
          const setMonthByOffset = async (delta) => {
            // Prevent watcher from triggering during month change
            changingMonth.value = true;

            try {
              // update offset
              currentMonthOffset.value = (currentMonthOffset.value || 0) + delta;

              const { start, end } = getMonthRange(currentMonthOffset.value);

              console.log('üîÑ setMonthByOffset', {
                delta,
                newOffset: currentMonthOffset.value,
                dateRange: `${formatLocalDate(start)} ‚Üí ${formatLocalDate(end)}`,
              });

              // Set date range - zawsze u≈ºywaj from/to dla month navigation
              filterParams.value.from = formatLocalDate(start);
              filterParams.value.to = formatLocalDate(end);
              // filterMode remains as user selected in UI

              // First: read data from DB for immediate UX
              // (fetchBookings will call /ical/data with from/to and render rows)
              await fetchBookings(1);

              // Then: start a background synchronization to update DB FOR THIS SPECIFIC MONTH
              // After sync completes, refresh data to show newly synced bookings
              if (isAdmin.value) {
                try {
                  // mark background sync in UI
                  backgroundSyncing.value = true;
                  // Pass the specific month dates to sync
                  await handleSync(false, formatLocalDate(start), formatLocalDate(end));
                  // Refresh data after background sync completes
                  await fetchBookings(1);
                } catch (err) {
                  console.error('Background sync failed:', err);
                } finally {
                  backgroundSyncing.value = false;
                }
              }
            } finally {
              // Re-enable watcher after month change completes
              changingMonth.value = false;
            }
          };

          // Convenience wrappers
          const setCurrentMonth = async () => {
            // Prevent watcher from triggering during month change
            changingMonth.value = true;

            try {
              // Reset offset to 0 and reload current month
              currentMonthOffset.value = 0;
              const { start, end } = getMonthRange(0);
              filterParams.value.from = formatLocalDate(start);
              filterParams.value.to = formatLocalDate(end);
              // filterMode remains as user selected in UI
              await fetchBookings(1);

              // Background sync for current month (tylko admin)
              if (isAdmin.value) {
                try {
                  backgroundSyncing.value = true;
                  await handleSync(false, formatLocalDate(start), formatLocalDate(end));
                  // Refresh after sync
                  await fetchBookings(1);
                } catch (e) {
                  console.error('Background sync failed:', e);
                } finally {
                  backgroundSyncing.value = false;
                }
              }
            } finally {
              // Re-enable watcher after month change completes
              changingMonth.value = false;
            }
          };

          const setPreviousMonth = () => setMonthByOffset(-1);

          const setNextMonth = () => setMonthByOffset(1);

          // Human-friendly label for the currently displayed month (based on offset)
          const displayedMonthLabel = computed(() => {
            const now = new Date();
            const d = new Date(
              now.getFullYear(),
              now.getMonth() + (currentMonthOffset.value || 0),
              1,
            );
            // e.g. "grudzie≈Ñ 2025"
            return d.toLocaleDateString('pl-PL', { month: 'long', year: 'numeric' });
          });

          const fetchProperties = async () => {
            try {
              const res = await fetch('/ical/properties');
              const data = await res.json();
              // Group properties by name and take the cleaning cost from any source (they should be the same for logical property)
              const propMap = new Map();
              data.properties.forEach((p) => {
                if (!propMap.has(p.name)) {
                  propMap.set(p.name, { cleaningCost: p.cleaningCost || 0, sources: [] });
                }
                propMap.get(p.name).sources.push(p.source);
              });
              propertiesWithCosts.value = Array.from(propMap.entries()).map(([name, data]) => ({
                name,
                cleaningCost: data.cleaningCost,
                sources: data.sources,
              }));
            } catch (e) {
              console.error('Failed to fetch properties:', e);
            }
          };

          // Fetch live iCal reservations for an explicit range (does not write to DB)
          const fetchICalRange = async (fromDate, toDate) => {
            changingMonth.value = true;
            loading.value = true;
            error.value = '';
            try {
              const params = new URLSearchParams({
                from: fromDate,
                to: toDate,
                sortBy: String(filterParams.value.sortBy),
              });

              if (selectedGroup.value) params.set('groupId', selectedGroup.value);
              if (selectedApartments.value.length > 0)
                params.set('propertyNames', selectedApartments.value.join(','));

              const res = await fetch(`/ical/fetch?${params.toString()}`);
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'B≈ÇƒÖd');

              const mappedRows = mapBookingData(data.rows);
              allRows.value = mappedRows;
              rows.value = mappedRows;
              currentPage.value = 1;
              hasMore.value = false;
              totalCount.value = mappedRows.length;
            } catch (e) {
              error.value = e.message || 'B≈ÇƒÖd podczas pobierania iCal';
            } finally {
              loading.value = false;
              changingMonth.value = false;
            }
          };

          // Watchers dla filtr√≥w - je≈õli siƒô zmieniƒÖ, resetuj paginacjƒô
          // KROK 2: Debounce TYLKO dla rƒôcznych zmian (nie dla month change)
          let watcherDebounceTimer = null;
          watch(
            [
              () => filterParams.value.from,
              () => filterParams.value.to,
              () => filterParams.value.includeCancelled,
              () => filterParams.value.filterMode,
              selectedGroup,
              selectedApartments,
              showCancelled,
            ],
            async () => {
              // Zapisz filterMode do localStorage
              localStorage.setItem('filterMode', filterParams.value.filterMode);

              // Pomij je≈õli month change jest w trakcie - changeMonth() ju≈º siƒô wywo≈Ça
              if (changingMonth.value) return;

              // Sync showCancelled to filterParams
              filterParams.value.includeCancelled = showCancelled.value;

              // Debounce manual changes
              if (watcherDebounceTimer) clearTimeout(watcherDebounceTimer);
              watcherDebounceTimer = setTimeout(async () => {
                currentPage.value = 1;
                allRows.value = [];
                rows.value = [];
                await fetchBookings(1);
              }, 300);
            },
          );

          // Watch for apartment selection changes - filtering done on frontend, no need to fetch
          watch(
            selectedApartments,
            () => {
              // Frontend filtering only
            },
            { deep: true },
          );

          const fetchGroups = async () => {
            try {
              const res = await fetch('/ical/groups');
              const data = await res.json();
              groups.value = data.groups;
            } catch (e) {
              console.error('Failed to fetch groups:', e);
            }
          };
          // Main data array (all fetched rows)
          const allRows = ref([]);

          // Paginacja
          const currentPage = ref(1);
          const pageSize = ref(30);
          const hasMore = ref(false);
          const totalCount = ref(0);
          const isLoadingMore = ref(false);

          // Infinite Scroll
          const sentinelElement = ref(null);
          const infiniteScrollEnabled = ref(true);
          let intersectionObserver = null;

          // Nowa ujednolicona funkcja do pobierania rezerwacji
          const fetchBookings = async (page = 1) => {
            if (page === 1) {
              loading.value = true;
            } else {
              isLoadingMore.value = true;
            }
            error.value = '';
            try {
              const params = new URLSearchParams({
                page: String(page),
              });

              // Always use from/to dates
              params.set('all', 'true');
              params.set('limit', '1000');
              params.set('from', filterParams.value.from);
              params.set('to', filterParams.value.to);
              params.set('filterMode', filterParams.value.filterMode);

              if (filterParams.value.includeCancelled) params.set('includeCancelled', 'true');
              if (selectedGroup.value) params.set('groupId', selectedGroup.value);

              console.log('üìÖ Fetching bookings:', {
                from: filterParams.value.from,
                to: filterParams.value.to,
                sortBy: filterParams.value.sortBy,
                filterMode: filterParams.value.filterMode,
                url: `/ical/data?${params.toString()}`,
              });

              const res = await fetch(`/ical/data?${params.toString()}`);
              const data = await res.json();

              console.log('üìä Received bookings:', {
                count: data.count,
                totalCount: data.totalCount,
                hasMore: data.hasMore,
                from: filterParams.value.from,
                to: filterParams.value.to,
                page,
              });

              if (!data.success) throw new Error(data.error || 'B≈ÇƒÖd');

              const mappedRows = mapBookingData(data.rows);

              if (page === 1) {
                allRows.value = mappedRows;
                rows.value = mappedRows; // Sync for backward compatibility
              } else {
                allRows.value.push(...mappedRows);
                rows.value.push(...mappedRows);
              }

              currentPage.value = page;
              hasMore.value = data.hasMore;
              totalCount.value = data.totalCount;
            } catch (e) {
              error.value = e.message || 'B≈ÇƒÖd';
            } finally {
              loading.value = false;
              isLoadingMore.value = false;
            }
          };

          const loadMore = () => {
            if (!isLoadingMore.value && hasMore.value) {
              fetchBookings(currentPage.value + 1);
            }
          };

          // Flag for month/range changes
          const changingMonth = ref(false);

          // Funkcja pomocnicza do updatowania progress
          const updateProgress = (percentage, status, message) => {
            syncProgress.value = {
              show: true,
              percentage,
              status,
              message,
            };
          };

          // G≈Ç√≥wna funkcja synchronizacji z progress tracking
          const handleSync = async (showProgressBar = true, fromDate = null, toDate = null) => {
            if (!isAdmin.value) return; // Tylko admin mo≈ºe synchronizowaƒá
            if (syncing.value) return; // Unikaj duplikat√≥w

            syncing.value = true;
            try {
              if (showProgressBar) {
                updateProgress(10, 'fetching', 'Pobieranie listy nieruchomo≈õci...');
              }

              const syncData = {
                from: fromDate || filterParams.value.from,
                to: toDate || filterParams.value.to,
              };
              if (selectedGroup.value) {
                syncData.groupId = selectedGroup.value;
              }
              if (selectedApartments.value.length > 0) {
                syncData.propertyNames = selectedApartments.value.join(',');
              }

              if (showProgressBar) {
                updateProgress(30, 'syncing', 'Synchronizacja rezerwacji...');
              }

              const res = await fetch('/ical/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(syncData),
              });
              const data = await res.json();
              if (!data.success) throw new Error(data.error || 'Sync failed');

              if (showProgressBar) {
                updateProgress(70, 'syncing', 'Od≈õwie≈ºanie danych...');

                // Refresh data after sync ONLY if showing progress bar (manual sync)
                await fetchBookings(1);

                updateProgress(100, 'done', 'Synchronizacja zako≈Ñczona!');
                // Ukryj progress bar po 2 sekundach
                setTimeout(() => {
                  syncProgress.value.show = false;
                }, 2000);
              }

              // Poka≈º modal z wynikami tylko je≈õli pokazywali≈õmy progress
              if (showProgressBar) {
                setTimeout(() => {
                  showModal('Synchronizacja zako≈Ñczona!', data.message, data.stats);
                }, 2000);
              }
            } catch (e) {
              if (showProgressBar) {
                updateProgress(0, 'error', 'B≈ÇƒÖd synchronizacji');
                setTimeout(() => {
                  syncProgress.value.show = false;
                }, 2000);
              }
              showModal('B≈ÇƒÖd synchronizacji', e.message, null);
            } finally {
              syncing.value = false;
            }
          };

          const syncNow = async () => {
            await handleSync(true); // true = poka≈º progress bar dla manual sync
          };

          const showModal = (title, message, stats = null) => {
            // Translate stats keys to Polish
            const translatedStats = stats
              ? {
                  'Zsynchronizowane nieruchomo≈õci': stats.propertiesSynced,
                  'Zaktualizowane rezerwacje': stats.bookingsUpdated,
                  'Anulowane rezerwacje': stats.bookingsCancelled,
                }
              : null;

            modal.value = {
              show: true,
              title,
              message,
              stats: translatedStats,
            };
          };

          const closeModal = () => {
            modal.value.show = false;
          };

          // Load initial data when component mounts
          onMounted(async () => {
            try {
              // Krok 0: Pobierz rolƒô u≈ºytkownika
              await fetchRole();

              // Krok 1: Pobierz ustawienia aplikacji (domy≈õlna grupa)
              try {
                const settingsRes = await fetch('/ical/settings');
                const settingsData = await settingsRes.json();
                if (settingsData.success && settingsData.settings?.defaultGroupId) {
                  const gid =
                    settingsData.settings.defaultGroupId._id ||
                    settingsData.settings.defaultGroupId;
                  selectedGroup.value = String(gid);
                }
              } catch {
                // ignoruj ‚Äì brak ustawie≈Ñ nie blokuje aplikacji
              }

              // Krok 2: Paralelne ≈Çadowanie danych
              await Promise.all([fetchBookings(1), fetchProperties(), fetchGroups()]);

              // Krok 2: Automatyczna synchronizacja przy pierwszym wej≈õciu (tylko admin)
              if (!autoSyncDone && isAdmin.value) {
                autoSyncDone = true;
                await handleSync(false); // false = nie pokazuj progress baru dla auto-sync
              }

              // Krok 3: Setup Intersection Observer dla infinite scroll
              if (sentinelElement.value && 'IntersectionObserver' in window) {
                const observerOptions = {
                  root: null,
                  rootMargin: '100px',
                  threshold: 0.1,
                };

                intersectionObserver = new IntersectionObserver((entries) => {
                  entries.forEach((entry) => {
                    // Trigger loadMore je≈õli sentinel jest widoczny, jest wiƒôcej danych i nie ≈Çadujemy
                    if (entry.isIntersecting && hasMore.value && !isLoadingMore.value) {
                      loadMore();
                    }
                  });
                }, observerOptions);

                intersectionObserver.observe(sentinelElement.value);
              } else {
                // Fallback dla starszych przeglƒÖdarek - wy≈ÇƒÖcz infinite scroll
                infiniteScrollEnabled.value = false;
              }
            } catch (err) {
              console.error('B≈ÇƒÖd podczas inicjalizacji aplikacji:', err);
            }
          });

          // Cleanup observer na unmount
          onBeforeUnmount(() => {
            if (intersectionObserver) {
              intersectionObserver.disconnect();
            }
            // Clear any pending save timers to prevent memory leaks
            if (saveTimer) {
              clearTimeout(saveTimer);
            }
          });

          return {
            loading,
            error,
            rows,
            allRows,
            filterParams,
            sortBy,
            displayedMonthLabel,
            fetchBookings,
            fetchData,
            loadMore,
            currentPage,
            pageSize,
            hasMore,
            totalCount,
            isLoadingMore,
            sentinelElement,
            infiniteScrollEnabled,
            newName,
            newUrl,
            newSource,
            properties,
            appendConfig,
            updateGuests,
            updateNotes,
            saving,
            from,
            to,
            setCurrentMonth,
            setPreviousMonth,
            setNextMonth,
            selectedApartments,
            apartmentNames,
            filteredRows,
            showApartmentDropdown,
            currentSummary,
            selectedGroup,
            groups,
            groupsWithCounts,
            selectedGroupData,
            newBookingsCount,
            syncing,
            backgroundSyncing,
            syncNow,
            syncProgress,
            showCancelled,
            modal,
            showModal,
            closeModal,
            removeApartment,
            toggleApartment,
            changingMonth,
            userRole,
            isAdmin,
            logout,
          };
        },
        template: `
                <div class="container">
                  <!-- Progress Bar for Sync -->
                  <div v-if="syncProgress.show" class="sync-progress-bar">
                    <div class="progress-container">
                      <p class="progress-message">{{ syncProgress.message }}</p>
                      <div class="progress-bar">
                        <div class="progress-fill" :style="{ width: syncProgress.percentage + '%' }"></div>
                      </div>
                      <span class="progress-percentage">{{ syncProgress.percentage }}%</span>
                    </div>
                  </div>

                  <!-- Nag≈Ç√≥wek z nawigacjƒÖ i rolƒÖ -->
                  <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                    <a v-if="isAdmin" href="/config" class="config-button">Konfiguracja iCal</a>
                    <span v-else style="flex:1"></span>
                    <div style="display:flex; align-items:center; gap:10px;">
                      <span v-if="isAdmin" style="font-size:0.8rem; color:#94a3b8; background:rgba(66,153,225,0.15); border:1px solid rgba(66,153,225,0.3); border-radius:6px; padding:3px 10px;">üëë Admin</span>
                      <span v-else style="font-size:0.8rem; color:#718096; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:6px; padding:3px 10px;">üëÅ PrzeglƒÖdaj</span>
                      <a v-if="!isAdmin" href="/login" style="font-size:0.82rem; color:#4299e1; text-decoration:none; padding:3px 10px; border:1px solid rgba(66,153,225,0.4); border-radius:6px;">Zaloguj jako admin</a>
                      <button v-if="isAdmin" @click="logout" style="font-size:0.82rem; background:rgba(229,62,62,0.15); border:1px solid rgba(229,62,62,0.4); color:#fc8181; border-radius:6px; padding:3px 12px; cursor:pointer;">Wyloguj</button>
                    </div>
                  </div>

                  <h1>Rezerwacje</h1>

                  <!-- Group Selection Toolbar -->
                  <div class="toolbar mb-4">
                    <button
                      @click="selectedGroup = ''"
                      :class="['px-4 py-2 rounded', selectedGroup === '' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600']"
                    >
                      Wszystkie
                    </button>
                    <button
                      v-for="group in groupsWithCounts"
                      :key="group._id"
                      @click="selectedGroup = group._id"
                      :class="['px-4 py-2 rounded ml-2', selectedGroup === group._id ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600']"
                    >
                      {{ group.name }}
                      <span class="text-sm opacity-75">({{ group.propertyCount }} obj., {{ group.bookingCount }} rez.)</span>
                    </button>
                  </div>

                  <p style="display:flex; align-items:center; gap:10px;">Podsumowanie: {{ currentSummary }}
                    <span v-if="newBookingsCount > 0" class="new-badge">{{ newBookingsCount }} nowych</span>
                    <small v-if="backgroundSyncing" style="color:#ffd700; margin-left:8px; font-style:italic;">synchronizacja w tle...</small>
                  </p>

                  <!-- Main Controls Toolbar -->
                  <div class="main-toolbar">
                    <!-- Left Section: Filters -->
                    <div class="toolbar-section">
                      <div class="filter-group">
                        <label class="filter-label">Sortuj po:</label>
                        <select v-model="sortBy" class="filter-select">
                          <option value="start">przyje≈∫dzie</option>
                          <option value="end">wyje≈∫dzie</option>
                        </select>
                      </div>

                      <div class="filter-group">
                        <label class="filter-label">Od:</label>
                        <input type="date" v-model="from" class="filter-input"/>
                      </div>

                      <div class="filter-group">
                        <label class="filter-label">Do:</label>
                        <input type="date" v-model="to" class="filter-input"/>
                      </div>
                    </div>

                    <!-- Center Section: Quick Actions -->
                    <div class="toolbar-section">
                      <div class="button-group">
                        <button @click="setPreviousMonth" :disabled="changingMonth" class="action-button">{{ changingMonth ? '‚è≥' : '‚óÄ Poprzedni' }}</button>
                        <button @click="setCurrentMonth" :disabled="changingMonth" class="action-button primary">{{ changingMonth ? '≈Åadujƒô...' : 'Aktualny' }}</button>
                          <button @click="setNextMonth" :disabled="changingMonth" class="action-button">{{ changingMonth ? '‚è≥' : 'Nastƒôpny ‚ñ∂' }}</button>
                        </div>

                        <div class="month-label" style="margin-top:6px; text-align:center; color:#ddd; font-size:0.95rem;">
                          {{ displayedMonthLabel }}
                        </div>
                      </div>
                    </div>

                    <!-- Right Section: Main Actions -->
                    <div class="toolbar-section">
                      <div class="button-group">
                        <button @click="showCancelled = !showCancelled" :class="['action-button', showCancelled ? 'active' : '']">
                          {{ showCancelled ? 'Ukryj anulowane' : 'Poka≈º anulowane' }}
                        </button>
                        <button
                          @click="filterParams.filterMode = filterParams.filterMode === 'sortBy' ? 'overlap' : 'sortBy'"
                          :class="['action-button', filterParams.filterMode === 'overlap' ? 'active' : '']"
                          title="Tryb filtrowania: 'Wed≈Çug daty' pokazuje tylko rezerwacje z check-in/out w miesiƒÖcu. 'Wszystkie' pokazuje rezerwacje przecinajƒÖce miesiƒÖc."
                        >
                          {{ filterParams.filterMode === 'overlap' ? 'üìÖ Wszystkie' : 'üìÖ Wed≈Çug daty' }}
                        </button>
                        <button v-if="isAdmin" @click="syncNow" :disabled="syncing" class="action-button sync">
                          {{ syncing ? 'Synchronizujƒô...' : 'Synchronizuj iCal' }}
                        </button>
                      </div>
                    </div>
                  </div>
      <div class="apartment-dropdown-container">
        <div
          class="apartment-select-trigger"
          @click="showApartmentDropdown = !showApartmentDropdown"
          tabindex="0"
          @blur="showApartmentDropdown = false"
        >
          <span v-if="!selectedApartments || !selectedApartments.length" class="placeholder">Filtruj nieruchomo≈õci</span>
          <span v-else-if="selectedApartments && selectedApartments.length">
            <span v-for="apt in selectedApartments" :key="apt" class="chip">{{ apt }} <button @click.stop="removeApartment(apt)">√ó</button></span>
          </span>
          <span class="arrow">‚ñº</span>
        </div>
        <div
          v-if="showApartmentDropdown"
          class="apartment-dropdown"
          @mousedown.prevent
        >
          <label v-for="name in apartmentNames" :key="name" class="apartment-option" @click.prevent="toggleApartment(name)">
            <input
              type="checkbox"
              :checked="selectedApartments.includes(name)"
              @click.prevent
            />
            {{ name }}
          </label>
        </div>
      </div>
                  <div class="card">
                    <div v-if="loading">≈Åadowanie...</div>
                    <div v-else-if="error">B≈ÇƒÖd: {{ error }}</div>
                    <div v-else>
                      <div style="overflow-x:auto;">
                        <table>
                          <thead>
                            <tr>
                              <th>Nieruchomo≈õƒá</th>
                              <th>Check-in</th>
                              <th>Check-out</th>
                              <th>Status wyjazdu</th>
                              <th>Liczba go≈õci</th>
                              <th>Notatki</th>
                              <th class="muted">Opis</th>
                              <th class="muted">≈πr√≥d≈Ço</th>
                            </tr>
                          </thead>
                          <tbody>
                            <tr v-for="r in filteredRows" :key="r.id || r._id" :class="{ 'new-booking': r.isNew, 'cancelled-booking': r.cancellationStatus === 'cancelled' || r.cancellationStatus === true }">
                              <td>
                                {{ r['Nieruchomo≈õƒá'] }}
                                <span v-if="r.isNew" class="new-badge">NOWE</span>
                                <span v-if="r.isStartingToday" class="arrival-today-badge">PRZYJAZD</span>
                                <span v-if="r.cancellationStatus === 'cancelled' || r.cancellationStatus === true" class="cancelled-badge">üö´ ANULOWANA</span>
                              </td>
                              <td>{{ r['Data rozpoczƒôcia'] }}</td>
                              <td>{{ r['Data zako≈Ñczenia'] }}</td>
                              <td>
                                <span :class="['badge', r['Status wyjazdu'] === 'PILNE' ? 'badge-pilne' : 'badge-normalne']">
                                  {{ r['Status wyjazdu'] }}
                                </span>
                              </td>
                              <td>
                                <input v-if="isAdmin" class="input input-small" type="number" min="0" max="20" v-model.number="r['Liczba go≈õci']" @input="updateGuests(r)" />
                                <span v-else>{{ r['Liczba go≈õci'] }}</span>
                              </td>
                              <td>
                                <input v-if="isAdmin" class="input input-medium" type="text" v-model="r['Notatki']" @input="updateNotes(r)" />
                                <span v-else>{{ r['Notatki'] }}</span>
                              </td>
                              <td class="muted opis-cell">{{ r['Opis'] }}</td>
                              <td class="muted"><a :href="r['≈πr√≥d≈Ço']" target="_blank">≈∫r√≥d≈Ço</a></td>
                            </tr>
                          </tbody>
                        </table>
                      </div>
                      <div class="footer">Wskaz√≥wka: Status wyjazdu = "PILNE" oznacza przyjazd tego samego dnia. <span v-if="saving" class="saving-indicator">Zapisujƒô...</span></div>

                      <!-- Infinite Scroll Sentinel Element -->
                      <div ref="sentinelElement" class="sentinel-element"></div>

                      <!-- Manual Load More Button (fallback for touch devices) -->
                      <div v-if="hasMore && !infiniteScrollEnabled" style="text-align:center; margin-top:12px;">
                        <button class="load-more-btn" @click="loadMore" :disabled="isLoadingMore">
                          {{ isLoadingMore ? '≈Åadujƒô...' : 'Za≈Çaduj wiƒôcej' }} ({{ allRows.length }} / {{ totalCount }})
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Modal -->
                <div class="modal-overlay" :class="{ active: modal.show }" @click="closeModal">
                  <div class="modal-content" @click.stop>
                    <div class="modal-header">
                      <h3 class="modal-title">{{ modal.title }}</h3>
                      <button class="modal-close" @click="closeModal">&times;</button>
                    </div>
                    <div class="modal-body">
                      <p>{{ modal.message }}</p>
                      <div v-if="modal.stats" class="modal-stats">
                        <div v-for="(value, key) in modal.stats" :key="key" class="modal-stat">
                          <span class="modal-stat-label">{{ key }}:</span>
                          <span class="modal-stat-value">{{ value }}</span>
                        </div>
                      </div>
                    </div>
                    <div class="modal-actions">
                      <button class="modal-btn modal-btn-primary" @click="closeModal">OK</button>
                    </div>
                  </div>
                </div>
              `,
      }).mount('#app');
    </script>
  </body>
</html>
